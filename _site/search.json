[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS608 - Visual Analytics and Applications",
    "section": "",
    "text": "Welcome to Akshaya’s Visual Analytics Page.\nIn this website, you will find my coursework for the Visual Analytics and Applications module from Singapore Management University for Academic Year 2025-26 January term."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to Akshaya’s home page on Visual Analytics.\nIn this website, you will find my coursework for the Visual Analytics and Applications module from Singapore Management University for Academic Year 2025-26 January term."
  },
  {
    "objectID": "HE01.html",
    "href": "HE01.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This exercise introduces ggplot2’s core principles and key components. The objective is to gain practical experience applying these elements to create statistical graphics using the Layered Grammar of Graphics framework, and confidently use ggplot2’s essential graphical tools to produce elegant, effective visualizations."
  },
  {
    "objectID": "HE01.html#getting-started",
    "href": "HE01.html#getting-started",
    "title": "Hands-on Exercise 1",
    "section": "2 Getting Started",
    "text": "2 Getting Started\n\n2.1 Installing Required Libraries\nThe code chunk below uses p_load() of pacman package to check if tidyverse packages are installed in the computer. If they are, then they will be launched into R.\n\npacman::p_load(tidyverse)\n\n\n\n2.2 Loading Dataset\nThe dataset Exam_data.csv is loaded into the R environment using read_csv function of readr package, which is a package of tidyverse.\n\nexam_data &lt;- read_csv(\"Exam_data.csv\")\n\n\n\n2.3 Summary of Data\n\nsummary(exam_data)\n\n      ID               CLASS              GENDER              RACE          \n Length:322         Length:322         Length:322         Length:322        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n    ENGLISH          MATHS          SCIENCE     \n Min.   :21.00   Min.   : 9.00   Min.   :15.00  \n 1st Qu.:59.00   1st Qu.:58.00   1st Qu.:49.25  \n Median :70.00   Median :74.00   Median :65.00  \n Mean   :67.18   Mean   :69.33   Mean   :61.16  \n 3rd Qu.:78.00   3rd Qu.:85.00   3rd Qu.:74.75  \n Max.   :96.00   Max.   :99.00   Max.   :96.00  \n\n\n\nThis dataset contains the year end examination grades of a cohort of primary 3 students from a local school.\nThere are a total of seven attributes. Four of them are categorical data type and the other three are in continuous data type.\n\nThe categorical attributes are: ID, CLASS, GENDER and RACE.\nThe continuous attributes are: MATHS, ENGLISH and SCIENCE."
  },
  {
    "objectID": "HE01.html#installing-required-libraries-and-data",
    "href": "HE01.html#installing-required-libraries-and-data",
    "title": "Hands-on Exercise 1",
    "section": "Installing Required Libraries and Data",
    "text": "Installing Required Libraries and Data\n\npacman::p_load(tidyverse)\n\n\nexam_data &lt;- read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "HE01.html#r-graphics",
    "href": "HE01.html#r-graphics",
    "title": "Hands-on Exercise 1",
    "section": "R Graphics",
    "text": "R Graphics\n\nhist(exam_data$MATHS)"
  },
  {
    "objectID": "HE01.html#ggplot",
    "href": "HE01.html#ggplot",
    "title": "Hands-on Exercise 1",
    "section": "ggplot",
    "text": "ggplot\n\nggplot(data=exam_data, aes(x = MATHS)) +\n  geom_histogram(bins=10, \n                 boundary = 100,\n                 color=\"black\", \n                 fill=\"grey\") +\n  ggtitle(\"Distribution of Maths scores\")\n\n\n\n\n\n\n\n\n:::"
  },
  {
    "objectID": "HE01.html#introducing-ggplot",
    "href": "HE01.html#introducing-ggplot",
    "title": "Hands-on Exercise 1",
    "section": "3 Introducing ggplot",
    "text": "3 Introducing ggplot\nggplot is an R package (part of the tidyverse family) which is used for creating data-driven graphics, aiding in visual exploration and communication.\n\nR Graphicsggplot\n\n\n\nhist(exam_data$MATHS)\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data, aes(x = MATHS)) + geom_histogram(bins=10, boundary = 100, color=\"black\", fill=\"grey\") + ggtitle(\"Distribution of Maths scores\")\n\n\n\n\n\n\n\n\n\n\n\nWhile R graphics code is simpler, ggplot2 is preferred.\nAs Hadley Wickham notes, “The transferable skills from ggplot2 are not the idiosyncrasies of plotting syntax, but a powerful way of thinking about visualisation, as a way of mapping between variables and the visual properties of geometric objects that you can perceive.”"
  },
  {
    "objectID": "HE01.html#installing-required-libraries",
    "href": "HE01.html#installing-required-libraries",
    "title": "Hands-on Exercise 1",
    "section": "2.1 Installing Required Libraries",
    "text": "2.1 Installing Required Libraries\nThe code chunk below uses p_load() of pacman package to check if tidyverse packages are installed in the computer. If they are, then they will be launched into R.\n\npacman::p_load(tidyverse)"
  },
  {
    "objectID": "HE01.html#loading-dataset",
    "href": "HE01.html#loading-dataset",
    "title": "Hands-on Exercise 1",
    "section": "2.2 Loading Dataset",
    "text": "2.2 Loading Dataset\nThe dataset Exam_data.csv is loaded into the R environment using read_csv function of readr package, which is a package of tidyverse.\n\nexam_data &lt;- read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "HE01.html#geometric-objects-geom_bar",
    "href": "HE01.html#geometric-objects-geom_bar",
    "title": "Hands-on Exercise 1",
    "section": "7.1 Geometric Objects: geom_bar",
    "text": "7.1 Geometric Objects: geom_bar\nThe code chunk below plots a bar chart by using geom_bar().\n\nggplot(data=exam_data, aes(x=RACE)) + geom_bar()"
  },
  {
    "objectID": "HE01.html#geometric-objects-geom_dotplot",
    "href": "HE01.html#geometric-objects-geom_dotplot",
    "title": "Hands-on Exercise 1",
    "section": "7.2 Geometric Objects: geom_dotplot",
    "text": "7.2 Geometric Objects: geom_dotplot\nIn a dot plot, each dot’s width reflects the bin width (or maximum width based on the binning method), with dots stacked vertically—each representing a single observation.\nThe code chunk below uses ggplot2’s geom_dotplot() to create a dot plot.\n\nggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot(dotsize = 0.5)\n\n\n\n\n\n\n\n\nThe y scale is not very useful, in fact it is very misleading.\nThe code chunk below performs the following two steps:\n\nscale_y_continuous() is used to turn off the y-axis, and\nbinwidth argument is used to change the binwidth to 2.5.\n\n\nggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot(binwidth=2.5,         \n               dotsize = 0.5) +      \n  scale_y_continuous(NULL,           \n                     breaks = NULL)"
  },
  {
    "objectID": "HE01.html#geometric-objects-geom_histogram",
    "href": "HE01.html#geometric-objects-geom_histogram",
    "title": "Hands-on Exercise 1",
    "section": "7.3 Geometric Objects: geom_histogram()",
    "text": "7.3 Geometric Objects: geom_histogram()\nIn the code chunk below, geom_histogram() is used to create a simple histogram by using values in MATHS field of exam_data.\n\nggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_histogram() \n\n\n\n\n\n\n\n\nNote that the default bin is 30."
  },
  {
    "objectID": "HE01.html#modifying-a-geometric-object-by-changing-geom",
    "href": "HE01.html#modifying-a-geometric-object-by-changing-geom",
    "title": "Hands-on Exercise 1",
    "section": "7.4 Modifying a geometric object by changing geom()",
    "text": "7.4 Modifying a geometric object by changing geom()\nIn the code chunk below,\n\nbins argument is used to change the number of bins to 20\nfill argument is used to shade the histogram with light blue color\ncolor argument is used to change the outline colour of the bars in black\n\n\nggplot(data=exam_data, aes(x= MATHS)) +\n  geom_histogram(bins=20,            \n                 color=\"black\",      \n                 fill=\"light blue\")"
  },
  {
    "objectID": "HE01.html#modifying-a-geometric-object-by-changing-aes",
    "href": "HE01.html#modifying-a-geometric-object-by-changing-aes",
    "title": "Hands-on Exercise 1",
    "section": "7.5 Modifying a geometric object by changing aes()",
    "text": "7.5 Modifying a geometric object by changing aes()\nThe code chunk below changes the interior colour of the histogram (i.e. fill) by using sub-group of aesthetic().\n\nggplot(data=exam_data, aes(x= MATHS, \n           fill = GENDER)) +\n  geom_histogram(bins=20, \n                 color=\"grey30\")"
  },
  {
    "objectID": "HE01.html#geometric-objects-geom-density",
    "href": "HE01.html#geometric-objects-geom-density",
    "title": "Hands-on Exercise 1",
    "section": "7.6 Geometric Objects: geom-density()",
    "text": "7.6 Geometric Objects: geom-density()\ngeom_density() creates and plots a kernel density estimate, which is a smoothed version of a histogram.\nIt serves as an effective alternative to histograms for continuous data from smooth underlying distributions.\nThe code below visualizes the Maths scores distribution using a kernel density plot.\n\nggplot(data=exam_data, aes(x = MATHS)) + geom_density()   \n\n\n\n\n\n\n\n\nThe code chunk below plots two kernel density lines by using colour or fill arguments of aes()\n\nggplot(data=exam_data, aes(x = MATHS, colour = GENDER)) + geom_density()"
  },
  {
    "objectID": "HE01.html#geometric-objects-geom_boxplot",
    "href": "HE01.html#geometric-objects-geom_boxplot",
    "title": "Hands-on Exercise 1",
    "section": "7.7 Geometric Objects: geom_boxplot",
    "text": "7.7 Geometric Objects: geom_boxplot\ngeom_boxplot() displays continuous value list. It visualises five summary statistics (the median, two hinges and two whiskers), and all “outlying” points individually.\nThe code chunk below plots boxplots by using geom_boxplot().\n\nggplot(data=exam_data, \n       aes(y = MATHS,       \n           x= GENDER)) +    \n  geom_boxplot() \n\n\n\n\n\n\n\n\nNotches are used in box plots to help visually assess whether the medians of distributions differ. If the notches do not overlap, this is evidence that the medians are different.\nThe code chunk below plots the distribution of Maths scores by gender in notched plot instead of boxplot.\n\nggplot(data=exam_data, \n       aes(y = MATHS, \n           x= GENDER)) +\n  geom_boxplot(notch=TRUE)"
  },
  {
    "objectID": "HE01.html#geometric-objects-geom_violin",
    "href": "HE01.html#geometric-objects-geom_violin",
    "title": "Hands-on Exercise 1",
    "section": "7.8 Geometric Objects: geom_violin",
    "text": "7.8 Geometric Objects: geom_violin\ngeom_violin() creates violin plots for comparing multiple data distributions side-by-side. Unlike overlapping density curves that interfere visually, violin plots display distributions clearly adjacent to each other.\nThe code below visualizes the Maths score distribution by gender using a violin plot.\n\nggplot(data=exam_data, aes(y = MATHS, x= GENDER)) + geom_violin()"
  },
  {
    "objectID": "HE01.html#geometric-objects-geom_point",
    "href": "HE01.html#geometric-objects-geom_point",
    "title": "Hands-on Exercise 1",
    "section": "7.9 Geometric Objects: geom_point()",
    "text": "7.9 Geometric Objects: geom_point()\ngeom_point() is especially useful for creating scatterplot.\nThe code chunk below plots a scatterplot showing the Maths and English grades of pupils by using geom_point().\n\nggplot(data=exam_data, \n       aes(x= MATHS, \n           y=ENGLISH)) +\n  geom_point()"
  },
  {
    "objectID": "HE01.html#geom-objects-can-be-combined",
    "href": "HE01.html#geom-objects-can-be-combined",
    "title": "Hands-on Exercise 1",
    "section": "7.10 geom objects can be combined",
    "text": "7.10 geom objects can be combined\nThe code chunk below plots the data points on the boxplots by using both geom_boxplot() and geom_point().\n\nggplot(data=exam_data, \n       aes(y = MATHS, \n           x= GENDER)) +\n  geom_boxplot() +                    \n  geom_point(position=\"jitter\", \n             size = 0.5)"
  },
  {
    "objectID": "HE01.html#working-with-stat",
    "href": "HE01.html#working-with-stat",
    "title": "Hands-on Exercise 1",
    "section": "8.1 Working with stat()",
    "text": "8.1 Working with stat()\nThe boxplots below are incomplete because the positions of the means were not shown.\n\nggplot(data=exam_data, \n       aes(y = MATHS, x= GENDER)) +\n  geom_boxplot()"
  },
  {
    "objectID": "HE01.html#working-with-stat---the-stat_summary-method",
    "href": "HE01.html#working-with-stat---the-stat_summary-method",
    "title": "Hands-on Exercise 1",
    "section": "8.2 Working with stat - the stat_summary() method",
    "text": "8.2 Working with stat - the stat_summary() method\nThe code chunk below adds mean values by using stat_summary() function and overriding the default geom.\n\nggplot(data=exam_data, \n       aes(y = MATHS, x= GENDER)) +\n  geom_boxplot() +\n  stat_summary(geom = \"point\",       \n               fun = \"mean\",         \n               colour =\"red\",        \n               size=4)"
  },
  {
    "objectID": "HE01.html#working-with-stat---the-geom-method",
    "href": "HE01.html#working-with-stat---the-geom-method",
    "title": "Hands-on Exercise 1",
    "section": "8.3 Working with stat - the geom() method",
    "text": "8.3 Working with stat - the geom() method\nThe code chunk below adding mean values by using geom_() function and overriding the default stat.\n\nggplot(data=exam_data, \n       aes(y = MATHS, x= GENDER)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\",        \n             fun=\"mean\",           \n             colour=\"red\",          \n             size=4)"
  },
  {
    "objectID": "HE01.html#adding-a-best-fit-curve-on-a-scatterplot",
    "href": "HE01.html#adding-a-best-fit-curve-on-a-scatterplot",
    "title": "Hands-on Exercise 1",
    "section": "8.4 Adding a best fit curve on a scatterplot?",
    "text": "8.4 Adding a best fit curve on a scatterplot?\nThe scatterplot below shows the relationship of Maths and English grades of pupils. The interpretability of this graph can be improved by adding a best fit curve.\n\nggplot(data=exam_data, aes(x= MATHS, y=ENGLISH)) +\n  geom_point() \n\n\n\n\n\n\n\n\nIn the code chunk below, geom_smooth() is used to plot a best fit curve on the scatterplot.\n\nggplot(data=exam_data, \n       aes(x= MATHS, y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(size=0.5)\n\n\n\n\n\n\n\n\nThe default method used is loess. The default smoothing method can be overridden as shown below.\n\nggplot(data=exam_data, \n       aes(x= MATHS, \n           y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(method=lm, \n              linewidth=0.5)"
  },
  {
    "objectID": "HE01.html#working-with-facet_wrap",
    "href": "HE01.html#working-with-facet_wrap",
    "title": "Hands-on Exercise 1",
    "section": "9.1 Working with facet_wrap()",
    "text": "9.1 Working with facet_wrap()\nfacet_wrap wraps a 1d sequence of panels into 2d. This is generally a better use of screen space than facet_grid because most displays are roughly rectangular.\nThe code chunk below plots a trellis plot using facet-wrap().\n\nggplot(data=exam_data, \n       aes(x= MATHS)) +\n  geom_histogram(bins=20) +\n    facet_wrap(~ CLASS)"
  },
  {
    "objectID": "HE01.html#facet_grid-function",
    "href": "HE01.html#facet_grid-function",
    "title": "Hands-on Exercise 1",
    "section": "9.2 9.2. facet_grid() function",
    "text": "9.2 9.2. facet_grid() function\n\nggplot(data=exam_data, \n       aes(x= MATHS)) +\n  geom_histogram(bins=20) +\n    facet_grid(~ CLASS)"
  },
  {
    "objectID": "HE01.html#working-with-coordinate",
    "href": "HE01.html#working-with-coordinate",
    "title": "Hands-on Exercise 1",
    "section": "10.1 Working with Coordinate",
    "text": "10.1 Working with Coordinate\nBy the default, the bar chart of ggplot2 is in vertical form.\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nThe code chunk below flips the horizontal bar chart into vertical bar chart by using coord_flip().\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip()"
  },
  {
    "objectID": "HE01.html#changing-the-y--and-x-axis-range",
    "href": "HE01.html#changing-the-y--and-x-axis-range",
    "title": "Hands-on Exercise 1",
    "section": "10.2 Changing the y- and x-axis range",
    "text": "10.2 Changing the y- and x-axis range\nThe scatterplot below is slightly misleading because the y-axis and x-axis range are not equal.\n\nggplot(data=exam_data, \n       aes(x= MATHS, y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(method=lm, size=0.5)\n\n\n\n\n\n\n\n\nThe code chunk below fixed both the y-axis and x-axis range from 0-100.\n\nggplot(data=exam_data, \n       aes(x= MATHS, y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(method=lm, \n              size=0.5) +  \n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))"
  },
  {
    "objectID": "HE01.html#working-with-theme",
    "href": "HE01.html#working-with-theme",
    "title": "Hands-on Exercise 1",
    "section": "11.1 Working with theme",
    "text": "11.1 Working with theme\nThe code chunk below plot a horizontal bar chart using theme_gray().\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_gray()\n\n\n\n\n\n\n\n\nA horizontal bar chart plotted using theme_classic().\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_classic()\n\n\n\n\n\n\n\n\nA horizontal bar chart plotted using theme_minimal().\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_minimal()"
  },
  {
    "objectID": "HE01.html#learning-outcome",
    "href": "HE01.html#learning-outcome",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This exercise introduces ggplot2’s core principles and key components. The objective is to gain practical experience applying these elements to create statistical graphics using the Layered Grammar of Graphics framework, and confidently use ggplot2’s essential graphical tools to produce elegant, effective visualizations."
  },
  {
    "objectID": "HE01.html#grammar-of-graphics",
    "href": "HE01.html#grammar-of-graphics",
    "title": "Hands-on Exercise 1",
    "section": "4 Grammar of Graphics",
    "text": "4 Grammar of Graphics\nBefore starting with ggplot2, it’s essential to grasp the Grammar of Graphics principles. This framework, introduced by Leland Wilkinson (1999), decomposes statistical graphics into core components like scales and layers, answering: “What constitutes a statistical graphic?” In essence, it establishes rules for combining mathematical and aesthetic elements into coherent visualizations.\n\n4.1 Core Principles\nThe Grammar of Graphics rests on two key ideas:\n\nGraphics consist of distinct layers of grammatical elements\nMeaningful plots emerge through aesthetic mapping\n\nA robust grammar reveals the structure of complex graphics, uncovers connections between seemingly unrelated visualizations (Cox 1978), and provides a foundation for diverse chart types. While it defines “grammatically correct” graphics, some valid structures remain conceptually nonsensical\n\n\n4.2 Layered Grammar in ggplot2\nggplot2 implements Wilkinson’s framework through seven layered components (Wickham 2010): \nA short description of each building block are as follows:\n\nData: The dataset being plotted.\nAesthetics take attributes of the data and use them to influence visual characteristics, such as position, colours, size, shape, or transparency.\nGeometrics: The visual elements used for our data, such as point, bar or line.\nFacets split the data into subsets to create multiple variations of the same graph (paneling, multiple plots).\nStatistics, statiscal transformations that summarise data (e.g. mean, confidence intervals).\nCoordinate systems define the plane on which data are mapped on the graphic.\nThemes modify all non-data components of a plot, such as main title, sub-title, y-aixs title, or legend background."
  },
  {
    "objectID": "HE01.html#essential-grammatical-elements-in-ggplot2-data",
    "href": "HE01.html#essential-grammatical-elements-in-ggplot2-data",
    "title": "Hands-on Exercise 1",
    "section": "5 Essential Grammatical Elements in ggplot2: data",
    "text": "5 Essential Grammatical Elements in ggplot2: data\nLet us call the ggplot() function using the code chunk on the right.\n\nggplot(data=exam_data)\n\n\n\n\n\n\n\n\n\nWe notice that a blank canvas appears.\nggplot() initializes a ggplot object.\nThe data argument defines the dataset to be used for plotting.\nIf the dataset is not already a data.frame, it will be converted to one by fortify()."
  },
  {
    "objectID": "HE01.html#essential-grammatical-elements-in-ggplot2-aesthetic-mappings",
    "href": "HE01.html#essential-grammatical-elements-in-ggplot2-aesthetic-mappings",
    "title": "Hands-on Exercise 1",
    "section": "6 Essential Grammatical Elements in ggplot2: Aesthetic mappings",
    "text": "6 Essential Grammatical Elements in ggplot2: Aesthetic mappings\nAesthetic mappings take data attributes and map them to visual properties like position, color, size, shape, or transparency. Each visual characteristic encodes a data aspect to communicate information effectively.\nAll plot aesthetics are defined within the aes() function. (Later sections show how individual geom layers can have their own aes() specifications.)\nThe code chunk below demonstrates adding aesthetic mappings to a plot.\n\nggplot(data=exam_data, \n       aes(x= MATHS))\n\n\n\n\n\n\n\n\nggplot includes the x-axis and the axis’s label."
  },
  {
    "objectID": "HE01.html#essential-grammatical-elements-in-ggplot2-geom",
    "href": "HE01.html#essential-grammatical-elements-in-ggplot2-geom",
    "title": "Hands-on Exercise 1",
    "section": "7 Essential Grammatical Elements in ggplot2: geom",
    "text": "7 Essential Grammatical Elements in ggplot2: geom\nGeometric objects are the actual marks we put on a plot. Examples include:\n\ngeom_point for drawing individual points (e.g., a scatter plot)\ngeom_line for drawing lines (e.g., for a line charts)\ngeom_smooth for drawing smoothed lines (e.g., for simple trends or approximations)\ngeom_bar for drawing bars (e.g., for bar charts)\ngeom_histogram for drawing binned values (e.g. a histogram)\ngeom_polygon for drawing arbitrary shapes\ngeom_map for drawing polygons in the shape of a map! (You can access the data to use for these maps by using the map_data() function).\n\nA plot must have at least one geom; there is no upper limit. You can add a geom to a plot using the + operator. For complete list, please refer to here.\n\n7.1 Geometric Objects: geom_bar\nThe code chunk below plots a bar chart by using geom_bar().\n\nggplot(data=exam_data, aes(x=RACE)) + geom_bar()\n\n\n\n\n\n\n\n\n\n\n7.2 Geometric Objects: geom_dotplot\nIn a dot plot, each dot’s width reflects the bin width (or maximum width based on the binning method), with dots stacked vertically—each representing a single observation.\nThe code chunk below uses ggplot2’s geom_dotplot() to create a dot plot.\n\nggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot(dotsize = 0.5)\n\n\n\n\n\n\n\n\nThe y scale is not very useful, in fact it is very misleading.\nThe code chunk below performs the following two steps:\n\nscale_y_continuous() is used to turn off the y-axis, and\nbinwidth argument is used to change the binwidth to 2.5.\n\n\nggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot(binwidth=2.5,         \n               dotsize = 0.5) +      \n  scale_y_continuous(NULL,           \n                     breaks = NULL)  \n\n\n\n\n\n\n\n\n\n\n7.3 Geometric Objects: geom_histogram()\nIn the code chunk below, geom_histogram() is used to create a simple histogram by using values in MATHS field of exam_data.\n\nggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_histogram() \n\n\n\n\n\n\n\n\nNote that the default bin is 30.\n\n\n7.4 Modifying a geometric object by changing geom()\nIn the code chunk below,\n\nbins argument is used to change the number of bins to 20\nfill argument is used to shade the histogram with light blue color\ncolor argument is used to change the outline colour of the bars in black\n\n\nggplot(data=exam_data, aes(x= MATHS)) +\n  geom_histogram(bins=20,            \n                 color=\"black\",      \n                 fill=\"light blue\")\n\n\n\n\n\n\n\n\n\n\n7.5 Modifying a geometric object by changing aes()\nThe code chunk below changes the interior colour of the histogram (i.e. fill) by using sub-group of aesthetic().\n\nggplot(data=exam_data, aes(x= MATHS, \n           fill = GENDER)) +\n  geom_histogram(bins=20, \n                 color=\"grey30\")\n\n\n\n\n\n\n\n\n\n\n7.6 Geometric Objects: geom-density()\ngeom_density() creates and plots a kernel density estimate, which is a smoothed version of a histogram.\nIt serves as an effective alternative to histograms for continuous data from smooth underlying distributions.\nThe code below visualizes the Maths scores distribution using a kernel density plot.\n\nggplot(data=exam_data, aes(x = MATHS)) + geom_density()   \n\n\n\n\n\n\n\n\nThe code chunk below plots two kernel density lines by using colour or fill arguments of aes()\n\nggplot(data=exam_data, aes(x = MATHS, colour = GENDER)) + geom_density()\n\n\n\n\n\n\n\n\n\n\n7.7 Geometric Objects: geom_boxplot\ngeom_boxplot() displays continuous value list. It visualises five summary statistics (the median, two hinges and two whiskers), and all “outlying” points individually.\nThe code chunk below plots boxplots by using geom_boxplot().\n\nggplot(data=exam_data, \n       aes(y = MATHS,       \n           x= GENDER)) +    \n  geom_boxplot() \n\n\n\n\n\n\n\n\nNotches are used in box plots to help visually assess whether the medians of distributions differ. If the notches do not overlap, this is evidence that the medians are different.\nThe code chunk below plots the distribution of Maths scores by gender in notched plot instead of boxplot.\n\nggplot(data=exam_data, \n       aes(y = MATHS, \n           x= GENDER)) +\n  geom_boxplot(notch=TRUE)\n\n\n\n\n\n\n\n\n\n\n7.8 Geometric Objects: geom_violin\ngeom_violin() creates violin plots for comparing multiple data distributions side-by-side. Unlike overlapping density curves that interfere visually, violin plots display distributions clearly adjacent to each other.\nThe code below visualizes the Maths score distribution by gender using a violin plot.\n\nggplot(data=exam_data, aes(y = MATHS, x= GENDER)) + geom_violin()\n\n\n\n\n\n\n\n\n\n\n7.9 Geometric Objects: geom_point()\ngeom_point() is especially useful for creating scatterplot.\nThe code chunk below plots a scatterplot showing the Maths and English grades of pupils by using geom_point().\n\nggplot(data=exam_data, \n       aes(x= MATHS, \n           y=ENGLISH)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n7.10 geom objects can be combined\nThe code chunk below plots the data points on the boxplots by using both geom_boxplot() and geom_point().\n\nggplot(data=exam_data, \n       aes(y = MATHS, \n           x= GENDER)) +\n  geom_boxplot() +                    \n  geom_point(position=\"jitter\", \n             size = 0.5)"
  },
  {
    "objectID": "HE01.html#essential-grammatical-elements-in-ggplot2-stat",
    "href": "HE01.html#essential-grammatical-elements-in-ggplot2-stat",
    "title": "Hands-on Exercise 1",
    "section": "8 Essential Grammatical Elements in ggplot2: stat",
    "text": "8 Essential Grammatical Elements in ggplot2: stat\nThe Statistics functions statistically transform data, usually as some form of summary. For example:\n\nfrequency of values of a variable (bar graph)\n\na mean\na confidence limit\n\nThere are two ways to use these functions: add a stat_() function and override the default geom, or add a geom_() function and override the default stat.\n\n\n\n8.1 Working with stat()\nThe boxplots below are incomplete because the positions of the means were not shown.\n\nggplot(data=exam_data, \n       aes(y = MATHS, x= GENDER)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n8.2 Working with stat - the stat_summary() method\nThe code chunk below adds mean values by using stat_summary() function and overriding the default geom.\n\nggplot(data=exam_data, \n       aes(y = MATHS, x= GENDER)) +\n  geom_boxplot() +\n  stat_summary(geom = \"point\",       \n               fun = \"mean\",         \n               colour =\"red\",        \n               size=4)\n\n\n\n\n\n\n\n\n\n\n8.3 Working with stat - the geom() method\nThe code chunk below adding mean values by using geom_() function and overriding the default stat.\n\nggplot(data=exam_data, \n       aes(y = MATHS, x= GENDER)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\",        \n             fun=\"mean\",           \n             colour=\"red\",          \n             size=4)  \n\n\n\n\n\n\n\n\n\n\n8.4 Adding a best fit curve on a scatterplot?\nThe scatterplot below shows the relationship of Maths and English grades of pupils. The interpretability of this graph can be improved by adding a best fit curve.\n\nggplot(data=exam_data, aes(x= MATHS, y=ENGLISH)) +\n  geom_point() \n\n\n\n\n\n\n\n\nIn the code chunk below, geom_smooth() is used to plot a best fit curve on the scatterplot.\n\nggplot(data=exam_data, \n       aes(x= MATHS, y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(size=0.5)\n\n\n\n\n\n\n\n\nThe default method used is loess. The default smoothing method can be overridden as shown below.\n\nggplot(data=exam_data, \n       aes(x= MATHS, \n           y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(method=lm, \n              linewidth=0.5)"
  },
  {
    "objectID": "HE01.html#essential-grammatical-elements-in-ggplot2-facets",
    "href": "HE01.html#essential-grammatical-elements-in-ggplot2-facets",
    "title": "Hands-on Exercise 1",
    "section": "9 Essential Grammatical Elements in ggplot2: Facets",
    "text": "9 Essential Grammatical Elements in ggplot2: Facets\nFaceting creates small multiples (also called trellis plots), where each panel shows a different data subset. It serves as an alternative to aesthetics for displaying additional categorical variables.\nggplot2 offers two faceting methods: facet_grid() and facet_wrap().\n\n9.1 Working with facet_wrap()\nfacet_wrap wraps a 1d sequence of panels into 2d. This is generally a better use of screen space than facet_grid because most displays are roughly rectangular.\nThe code chunk below plots a trellis plot using facet-wrap().\n\nggplot(data=exam_data, \n       aes(x= MATHS)) +\n  geom_histogram(bins=20) +\n    facet_wrap(~ CLASS)\n\n\n\n\n\n\n\n\n\n\n9.2 Working with facet_grid()\nfacet_grid() forms a matrix of panels defined by row and column faceting variables. It is most useful when you have two discrete variables, and all combinations of the variables exist in the data.\nThe code chunk below plots a trellis plot using facet_grid().\n\nggplot(data=exam_data, \n       aes(x= MATHS)) +\n  geom_histogram(bins=20) +\n    facet_grid(~ CLASS)"
  },
  {
    "objectID": "HE01.html#essential-grammatical-elements-in-ggplot2-coordinates",
    "href": "HE01.html#essential-grammatical-elements-in-ggplot2-coordinates",
    "title": "Hands-on Exercise 1",
    "section": "10 Essential Grammatical Elements in ggplot2: Coordinates",
    "text": "10 Essential Grammatical Elements in ggplot2: Coordinates\nThe Coordinates functions map the position of objects onto the plane of the plot. There are a number of different possible coordinate systems to use, they are:\n\ncoord_cartesian(): the default Cartesian coordinate systems, where you specify x and y values (e.g. allows you to zoom in or out).\ncoord_flip(): a Cartesian system with the x and y flipped.\ncoord_fixed(): a Cartesian system with a “fixed” aspect ratio (e.g. 1.78 for a “widescreen” plot).\ncoord_quickmap(): a coordinate system that approximates a good aspect ratio for maps.\n\n\n10.1 Working with Coordinate\nBy the default, the bar chart of ggplot2 is in vertical form.\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nThe code chunk below flips the horizontal bar chart into vertical bar chart by using coord_flip().\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n10.2 Changing the y- and x-axis range\nThe scatterplot below is slightly misleading because the y-axis and x-axis range are not equal.\n\nggplot(data=exam_data, \n       aes(x= MATHS, y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(method=lm, size=0.5)\n\n\n\n\n\n\n\n\nThe code chunk below fixed both the y-axis and x-axis range from 0-100.\n\nggplot(data=exam_data, \n       aes(x= MATHS, y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(method=lm, \n              size=0.5) +  \n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))"
  },
  {
    "objectID": "HE01.html#essential-grammatical-elements-in-ggplot2-themes",
    "href": "HE01.html#essential-grammatical-elements-in-ggplot2-themes",
    "title": "Hands-on Exercise 1",
    "section": "11 Essential Grammatical Elements in ggplot2: themes",
    "text": "11 Essential Grammatical Elements in ggplot2: themes\nThemes control elements of the graph not related to the data. For example:\n\nbackground colour\nsize of fonts\ngridlines\ncolour of labels\n\nBuilt-in themes include: - theme_gray() (default) - theme_bw() - theme_classic()\nA list of theme can be found at this link. Each theme element can be conceived of as either a line (e.g. x-axis), a rectangle (e.g. graph background), or text (e.g. axis title).\n\n11.1 Working with theme\nThe code chunk below plot a horizontal bar chart using theme_gray().\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_gray()\n\n\n\n\n\n\n\n\nA horizontal bar chart plotted using theme_classic().\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_classic()\n\n\n\n\n\n\n\n\nA horizontal bar chart plotted using theme_minimal().\n\nggplot(data=exam_data, \n       aes(x=RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_minimal()"
  },
  {
    "objectID": "HE01.html#references",
    "href": "HE01.html#references",
    "title": "Hands-on Exercise 1",
    "section": "12 References",
    "text": "12 References\n\nKam, T.S. (2023). A Layered Grammar of Graphics: ggplot2 methods.\nHadley Wickham (2023) ggplot2: Elegant Graphics for Data Analysis. Online 3rd edition.\nWinston Chang (2013) R Graphics Cookbook 2nd edition. Online version.\nHealy, Kieran (2019) Data Visualization: A practical introduction. Online version\nLearning ggplot2 on Paper – Components\nLearning ggplot2 on Paper – Layer\nLearning ggplot2 on Paper – Scale"
  },
  {
    "objectID": "HE01.html#summary-of-data",
    "href": "HE01.html#summary-of-data",
    "title": "Hands-on Exercise 1",
    "section": "2.3 Summary of Data",
    "text": "2.3 Summary of Data\n\nsummary(exam_data)\n\n      ID               CLASS              GENDER              RACE          \n Length:322         Length:322         Length:322         Length:322        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n    ENGLISH          MATHS          SCIENCE     \n Min.   :21.00   Min.   : 9.00   Min.   :15.00  \n 1st Qu.:59.00   1st Qu.:58.00   1st Qu.:49.25  \n Median :70.00   Median :74.00   Median :65.00  \n Mean   :67.18   Mean   :69.33   Mean   :61.16  \n 3rd Qu.:78.00   3rd Qu.:85.00   3rd Qu.:74.75  \n Max.   :96.00   Max.   :99.00   Max.   :96.00  \n\n\n\nThis dataset contains the year end examination grades of a cohort of primary 3 students from a local school.\nThere are a total of seven attributes. Four of them are categorical data type and the other three are in continuous data type.\n\nThe categorical attributes are: ID, CLASS, GENDER and RACE.\nThe continuous attributes are: MATHS, ENGLISH and SCIENCE."
  },
  {
    "objectID": "HE01.html#core-principles",
    "href": "HE01.html#core-principles",
    "title": "Hands-on Exercise 1",
    "section": "4.1 Core Principles",
    "text": "4.1 Core Principles\nThe Grammar of Graphics rests on two key ideas:\n\nGraphics consist of distinct layers of grammatical elements\nMeaningful plots emerge through aesthetic mapping\n\nA robust grammar reveals the structure of complex graphics, uncovers connections between seemingly unrelated visualizations (Cox 1978), and provides a foundation for diverse chart types. While it defines “grammatically correct” graphics, some valid structures remain conceptually nonsensical"
  },
  {
    "objectID": "HE01.html#layered-grammar-in-ggplot2",
    "href": "HE01.html#layered-grammar-in-ggplot2",
    "title": "Hands-on Exercise 1",
    "section": "4.2 Layered Grammar in ggplot2",
    "text": "4.2 Layered Grammar in ggplot2\nggplot2 implements Wilkinson’s framework through seven layered components (Wickham 2010):\n\n\n\nHadley Wickham (2010) “A layered grammar of graphics.” Journal of Computational and Graphical Statistics, vol. 19, no. 1, pp. 3–28.\n\n\nA short description of each building block are as follows:\n\nData: The dataset being plotted.\nAesthetics take attributes of the data and use them to influence visual characteristics, such as position, colours, size, shape, or transparency.\nGeometrics: The visual elements used for our data, such as point, bar or line.\nFacets split the data into subsets to create multiple variations of the same graph (paneling, multiple plots).\nStatistics, statiscal transformations that summarise data (e.g. mean, confidence intervals).\nCoordinate systems define the plane on which data are mapped on the graphic.\nThemes modify all non-data components of a plot, such as main title, sub-title, y-aixs title, or legend background."
  },
  {
    "objectID": "HE01.html#working-with-facet_grid",
    "href": "HE01.html#working-with-facet_grid",
    "title": "Hands-on Exercise 1",
    "section": "9.2 Working with facet_grid()",
    "text": "9.2 Working with facet_grid()\nfacet_grid() forms a matrix of panels defined by row and column faceting variables. It is most useful when you have two discrete variables, and all combinations of the variables exist in the data.\nThe code chunk below plots a trellis plot using facet_grid().\n\nggplot(data=exam_data, \n       aes(x= MATHS)) +\n  geom_histogram(bins=20) +\n    facet_grid(~ CLASS)"
  },
  {
    "objectID": "HE02.html#installing-and-loading-required-libraries",
    "href": "HE02.html#installing-and-loading-required-libraries",
    "title": "Hands-on Exercise 2",
    "section": "2.1 Installing and Loading Required Libraries",
    "text": "2.1 Installing and Loading Required Libraries\nIn this exercise, in addition to tidyverse, four additional R packages will be used:\n\nggrepel – provides ggplot2 geoms that prevent overlapping text labels.\nggthemes – offers additional themes, geoms, and scales to enhance ggplot2 visualizations.\nhrbrthemes – supplies typography-focused themes and components for ggplot2.\npatchwork – enables the creation of composite figures by combining multiple ggplot2 plots.\n\nThe code chunk below will check whether these packages are installed and then load them into the current R environment.\n\npacman::p_load(ggrepel, patchwork, hrbrthemes, ggthemes, tidyverse)"
  },
  {
    "objectID": "HE02.html#importing-data",
    "href": "HE02.html#importing-data",
    "title": "Hands-on Exercise 2",
    "section": "2.2 Importing Data",
    "text": "2.2 Importing Data\nFor the purpose of this exercise, a data file called Exam_data will be used. It consists of year end examination grades of a cohort of primary 3 students from a local school. It is in csv file format.\nThe code chunk below imports exam_data.csv into R environment by using read_csv()function of readr package. readr is one of the tidyverse package.\n\nexam_data &lt;- read_csv(\"Exam_data.csv\")\n\n\nsummary(exam_data)\n\n      ID               CLASS              GENDER              RACE          \n Length:322         Length:322         Length:322         Length:322        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n    ENGLISH          MATHS          SCIENCE     \n Min.   :21.00   Min.   : 9.00   Min.   :15.00  \n 1st Qu.:59.00   1st Qu.:58.00   1st Qu.:49.25  \n Median :70.00   Median :74.00   Median :65.00  \n Mean   :67.18   Mean   :69.33   Mean   :61.16  \n 3rd Qu.:78.00   3rd Qu.:85.00   3rd Qu.:74.75  \n Max.   :96.00   Max.   :99.00   Max.   :96.00  \n\n\nThere are a total of seven attributes in the exam_data tibble data frame. Four of them are categorical data type and the other three are in continuous data type.\n\nThe categorical attributes are: ID, CLASS, GENDER and RACE.\nThe continuous attributes are: MATHS, ENGLISH and SCIENCE."
  },
  {
    "objectID": "HE02.html#working-with-ggrepel",
    "href": "HE02.html#working-with-ggrepel",
    "title": "Hands-on Exercise 2",
    "section": "3.1 Working with ggrepel",
    "text": "3.1 Working with ggrepel\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data, aes(x= MATHS, y=ENGLISH)) +\n  geom_point() +\n  geom_smooth(method=lm, size=0.5) +  \n  geom_label_repel(aes(label = ID), fontface = \"bold\") +\n  coord_cartesian(xlim=c(0,100), ylim=c(0,100)) +\n  ggtitle(\"English scores versus Maths scores for Primary 3\")"
  },
  {
    "objectID": "HE02.html#working-with-ggtheme-package",
    "href": "HE02.html#working-with-ggtheme-package",
    "title": "Hands-on Exercise 2",
    "section": "4.1 Working with ggtheme package",
    "text": "4.1 Working with ggtheme package\nggthemes provides ‘ggplot2’ themes that replicate the look of plots by Edward Tufte, Stephen Few, Fivethirtyeight, The Economist, ‘Stata’, ‘Excel’, and The Wall Street Journal, among others.\nIn the example below, The Economist theme is used.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data, aes(x = MATHS)) +\n  geom_histogram(bins=20, \n                 boundary = 100,\n                 color=\"grey25\", \n                 fill=\"grey90\") +\n  ggtitle(\"Distribution of Maths scores\") +\n  theme_economist()\n\n\n\n\nIt also provides some extra geoms and scales for ‘ggplot2’. Consult this vignette to learn more."
  },
  {
    "objectID": "HE02.html#working-with-hrbthems-package",
    "href": "HE02.html#working-with-hrbthems-package",
    "title": "Hands-on Exercise 2",
    "section": "4.2 Working with hrbthems package",
    "text": "4.2 Working with hrbthems package\nhrbrthemes package provides a base theme that focuses on typographic elements, including where various labels are placed as well as the fonts that are used.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data, \n             aes(x = MATHS)) +\n  geom_histogram(bins=20, \n                 boundary = 100,\n                 color=\"grey25\", \n                 fill=\"grey90\") +\n  ggtitle(\"Distribution of Maths scores\") +\n  theme_ipsum()\n\n\n\n\nThe second goal centers around productivity for a production workflow. In fact, this “production workflow” is the context for where the elements of hrbrthemes should be used. Consult this vignette to learn more.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data, \n             aes(x = MATHS)) +\n  geom_histogram(bins=20, \n                 boundary = 100,\n                 color=\"grey25\", \n                 fill=\"grey90\") +\n  ggtitle(\"Distribution of Maths scores\") +\n  theme_ipsum(axis_title_size = 18,\n              base_size = 15,\n              grid = \"Y\")\n\n\n\n\nWhat can we learn from the code chunk above?\n\naxis_title_size argument is used to increase the font size of the axis title to 18,\nbase_size argument is used to increase the default axis label to 15,\nand grid argument is used to remove the x-axis grid lines."
  },
  {
    "objectID": "HE02.html#creating-composite-graphics-pathwork-methods",
    "href": "HE02.html#creating-composite-graphics-pathwork-methods",
    "title": "Hands-on Exercise 2",
    "section": "5.1 Creating Composite Graphics: pathwork methods",
    "text": "5.1 Creating Composite Graphics: pathwork methods\nThere are several ggplot2 extension’s functions support the needs to prepare composite figure by combining several graphs such as grid.arrange() of gridExtra package and plot_grid() of cowplot package. In this section, I am going to shared with you an ggplot2 extension called patchwork which is specially designed for combining separate ggplot2 graphs into a single figure.\nPatchwork package has a very simple syntax where we can create layouts super easily. Here’s the general syntax that combines:\n\nTwo-Column Layout using the Plus Sign +.\nParenthesis () to create a subplot group.\nTwo-Row Layout using the Division Sign /"
  },
  {
    "objectID": "HE02.html#combining-two-ggplot2-graphs",
    "href": "HE02.html#combining-two-ggplot2-graphs",
    "title": "Hands-on Exercise 2",
    "section": "5.2 Combining two ggplot2 graphs",
    "text": "5.2 Combining two ggplot2 graphs\nFigure in the tabset below shows a composite of two histograms created using patchwork. Note how simple the syntax used to create the plot!\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np1 + p2"
  },
  {
    "objectID": "HE02.html#combining-three-ggplot2-graphs",
    "href": "HE02.html#combining-three-ggplot2-graphs",
    "title": "Hands-on Exercise 2",
    "section": "5.3 Combining three ggplot2 graphs",
    "text": "5.3 Combining three ggplot2 graphs\nMore complex composite can be plotted by using appropriate operators. For example, the composite figure below is plotted by using:\n\n“/” operator to stack two ggplot2 graphs,\n“|” operator to place the plots beside each other,\n“()” operator the define the sequence of the plotting.\n\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(p1 / p2) | p3\n\n\n\n\nTo learn more about, refer to Plot Assembly."
  },
  {
    "objectID": "HE02.html#creating-a-composite-figure-with-tag",
    "href": "HE02.html#creating-a-composite-figure-with-tag",
    "title": "Hands-on Exercise 2",
    "section": "5.4 Creating a composite figure with tag",
    "text": "5.4 Creating a composite figure with tag\nIn order to identify subplots in text, patchwork also provides auto-tagging capabilities as shown in the figure below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n((p1 / p2) | p3) + \n  plot_annotation(tag_levels = 'I')"
  },
  {
    "objectID": "HE02.html#creating-figure-with-insert",
    "href": "HE02.html#creating-figure-with-insert",
    "title": "Hands-on Exercise 2",
    "section": "5.5 Creating figure with insert",
    "text": "5.5 Creating figure with insert\nBeside providing functions to place plots next to each other based on the provided layout. With inset_element() of patchwork, we can place one or several plots or graphic elements freely on top or below another plot.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np3 + inset_element(p2, \n                   left = 0.02, \n                   bottom = 0.7, \n                   right = 0.5, \n                   top = 1)"
  },
  {
    "objectID": "HE02.html#creating-a-composite-figure-by-using-patchwork-and-ggtheme",
    "href": "HE02.html#creating-a-composite-figure-by-using-patchwork-and-ggtheme",
    "title": "Hands-on Exercise 2",
    "section": "5.6 Creating a composite figure by using patchwork and ggtheme",
    "text": "5.6 Creating a composite figure by using patchwork and ggtheme\nFigure below is created by combining patchwork and theme_economist() of ggthemes package discussed earlier.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npatchwork &lt;- (p1 / p2) | p3\npatchwork & theme_economist()"
  },
  {
    "objectID": "HE02.html",
    "href": "HE02.html",
    "title": "Hands-on Exercise 2",
    "section": "",
    "text": "This exercise explores several ggplot2 extensions that enhance the elegance and effectiveness of statistical graphics. The objectives are to:\n\nControl the placement of annotations on graphs using functions from the ggrepel package.\nCreate professional, publication-quality figures with functions from the ggthemes and hrbrthemes packages.\nCombine multiple ggplot2 graphs into composite figures using the patchwork package."
  },
  {
    "objectID": "HE03.2.html#loading-the-r-packages",
    "href": "HE03.2.html#loading-the-r-packages",
    "title": "Hands-on Exercise 3-B",
    "section": "2.1 Loading the R packages",
    "text": "2.1 Loading the R packages\nFirst, write a code chunk to check, install and load the following R packages:\n\nplotly, R library for plotting interactive statistical graphs.\ngganimate, an ggplot extension for creating animated statistical graphs.\ngifski converts video frames to GIF animations using pngquant’s fancy features for efficient cross-frame palettes and temporal dithering. It produces animated GIFs that use thousands of colors per frame.\ngapminder: An excerpt of the data available at Gapminder.org. We just want to use its country_colors scheme.\ntidyverse, a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.\n\n\npacman::p_load(readxl, gifski, gapminder,\n               plotly, gganimate, tidyverse)"
  },
  {
    "objectID": "HE03.2.html#importing-the-data",
    "href": "HE03.2.html#importing-the-data",
    "title": "Hands-on Exercise 3-B",
    "section": "2.2 Importing the data",
    "text": "2.2 Importing the data\nIn this hands-on exercise, the Data worksheet from GlobalPopulation Excel workbook will be used.\n\ncol &lt;- c(\"Country\", \"Continent\")\nglobalPop &lt;- read_xls(\"GlobalPopulation.xls\",\n                      sheet=\"Data\") %&gt;%\n  mutate_each_(funs(factor(.)), col) %&gt;%\n  mutate(Year = as.integer(Year))\n\n\n\n\n\n\n\nTipThings to learn from the code chunk above\n\n\n\n\nread_xls() of readxl package is used to import the Excel worksheet.\nmutate_each_() of dplyr package is used to convert all character data type into factor.\nmutate of dplyr package is used to convert data values of Year field into integer.\n\n\n\nUnfortunately, mutate_each_() was deprecated in dplyr 0.7.0. and funs() was deprecated in dplyr 0.8.0. In view of this, the code will be rewritten using mutate_at() as shown in the code chunk below.\n\ncol &lt;- c(\"Country\", \"Continent\")\nglobalPop &lt;- read_xls(\"GlobalPopulation.xls\",\n                      sheet=\"Data\") %&gt;%\n  mutate_at(col, as.factor) %&gt;%\n  mutate(Year = as.integer(Year))\n\nInstead of using mutate_at(), across() can be used to derive the same outputs.\n\ncol &lt;- c(\"Country\", \"Continent\")\nglobalPop &lt;- read_xls(\"GlobalPopulation.xls\",\n                      sheet=\"Data\") %&gt;%\n  mutate(across(col, as.factor)) %&gt;%\n  mutate(Year = as.integer(Year))"
  },
  {
    "objectID": "HE03.2.html#building-a-static-population-bubble-plot",
    "href": "HE03.2.html#building-a-static-population-bubble-plot",
    "title": "Hands-on Exercise 3-B",
    "section": "3.1 Building a static population bubble plot",
    "text": "3.1 Building a static population bubble plot\nIn the code chunk below, the basic ggplot2 functions are used to create a static bubble plot.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(globalPop, aes(x = Old, y = Young, \n                      size = Population, \n                      colour = Country)) +\n  geom_point(alpha = 0.7, \n             show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(title = 'Year: {frame_time}', \n       x = '% Aged', \n       y = '% Young')"
  },
  {
    "objectID": "HE03.2.html#building-the-animated-bubble-plot",
    "href": "HE03.2.html#building-the-animated-bubble-plot",
    "title": "Hands-on Exercise 3-B",
    "section": "3.2 Building the animated bubble plot",
    "text": "3.2 Building the animated bubble plot\nIn the code chunk below,\n\ntransition_time() of gganimate is used to create transition through distinct states in time (i.e. Year).\nease_aes() is used to control easing of aesthetics. The default is linear. Other methods are: quadratic, cubic, quartic, quintic, sine, circular, exponential, elastic, back, and bounce.\n\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(globalPop, aes(x = Old, y = Young, \n                      size = Population, \n                      colour = Country)) +\n  geom_point(alpha = 0.7, \n             show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(title = 'Year: {frame_time}', \n       x = '% Aged', \n       y = '% Young') +\n  transition_time(Year) +       \n  ease_aes('linear')"
  },
  {
    "objectID": "HE03.2.html#building-an-animated-bubble-plot-ggplotly-method",
    "href": "HE03.2.html#building-an-animated-bubble-plot-ggplotly-method",
    "title": "Hands-on Exercise 3-B",
    "section": "4.1 Building an animated bubble plot: ggplotly() method",
    "text": "4.1 Building an animated bubble plot: ggplotly() method\nIn this sub-section, you will learn how to create an animated bubble plot by using ggplotly() method.\n\nPlotCode\n\n\n\n\n\n\n\n\nThe animated bubble plot above includes a play/pause button and a slider component for controlling the animation\n\n\n\ngg &lt;- ggplot(globalPop, \n       aes(x = Old, \n           y = Young, \n           size = Population, \n           colour = Country)) +\n  geom_point(aes(size = Population,\n                 frame = Year),\n             alpha = 0.7, \n             show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(x = '% Aged', \n       y = '% Young')\n\nggplotly(gg)\n\n\n\n\nNotice that although show.legend = FALSE argument was used, the legend still appears on the plot. To overcome this problem, theme(legend.position=‘none’) should be used as shown in the plot and code chunk below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\ngg &lt;- ggplot(globalPop, \n       aes(x = Old, \n           y = Young, \n           size = Population, \n           colour = Country)) +\n  geom_point(aes(size = Population,\n                 frame = Year),\n             alpha = 0.7) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(x = '% Aged', \n       y = '% Young') + \n  theme(legend.position='none')\n\nggplotly(gg)"
  },
  {
    "objectID": "HE03.2.html#building-an-animated-bubble-plot-plot_ly-method",
    "href": "HE03.2.html#building-an-animated-bubble-plot-plot_ly-method",
    "title": "Hands-on Exercise 3-B",
    "section": "4.2 Building an animated bubble plot: plot_ly() method",
    "text": "4.2 Building an animated bubble plot: plot_ly() method\nThis sub-section discusses how to create an animated bubble plot by using plot_ly() method.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\nbp &lt;- globalPop %&gt;%\n  plot_ly(x = ~Old, \n          y = ~Young, \n          size = ~Population, \n          color = ~Continent,\n          sizes = c(2, 100),\n          frame = ~Year, \n          text = ~Country, \n          hoverinfo = \"text\",\n          type = 'scatter',\n          mode = 'markers'\n          ) %&gt;%\n  layout(showlegend = FALSE)\nbp"
  },
  {
    "objectID": "HE03.1.html#tooltip-effect-with-tooltip-aesthetic",
    "href": "HE03.1.html#tooltip-effect-with-tooltip-aesthetic",
    "title": "Hands-on Exercise 3-A",
    "section": "4.1 Tooltip effect with tooltip aesthetic",
    "text": "4.1 Tooltip effect with tooltip aesthetic\nThe following example illustrates a typical code chunk for creating an interactive statistical plot using the ggiraph package. The code consists of two main parts: first, a ggplot object is constructed; then, the girafe() function from ggiraph is applied to convert the plot into an interactive SVG graphic.\n\np &lt;- ggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_dotplot_interactive(\n    aes(tooltip = ID),\n    stackgroups = TRUE, \n    binwidth = 1, \n    method = \"histodot\") +\n  scale_y_continuous(NULL, \n                     breaks = NULL)\ngirafe(\n  ggobj = p,\n  width_svg = 6,\n  height_svg = 6*0.618\n)\n\nThe process involves two key steps. First, an interactive ggplot2 geometry such as geom_dotplot_interactive() is used to build the base plot. Then, the girafe() function generates an interactive SVG object for display on an HTML page."
  },
  {
    "objectID": "HE03.1.html#displaying-multiple-information-on-tooltip",
    "href": "HE03.1.html#displaying-multiple-information-on-tooltip",
    "title": "Hands-on Exercise 3-A",
    "section": "5.1 Displaying multiple information on tooltip",
    "text": "5.1 Displaying multiple information on tooltip\nThe content of the tooltip can be customised by including a list object as shown in the code chunk below.\n\nexam_data$tooltip &lt;- c(paste0(     \n  \"Name = \", exam_data$ID,         \n  \"\\n Class = \", exam_data$CLASS)) \n\np &lt;- ggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_dotplot_interactive(\n    aes(tooltip = exam_data$tooltip), \n    stackgroups = TRUE,\n    binwidth = 1,\n    method = \"histodot\") +\n  scale_y_continuous(NULL,               \n                     breaks = NULL)\ngirafe(\n  ggobj = p,\n  width_svg = 8,\n  height_svg = 8*0.618\n)\n\nThe first three lines of codes in the code chunk create a new field called tooltip. At the same time, it populates text in ID and CLASS fields into the newly created field. Next, this newly created field is used as tooltip field as shown in the code of line 7."
  },
  {
    "objectID": "HE03.1.html#customising-tooltip-style",
    "href": "HE03.1.html#customising-tooltip-style",
    "title": "Hands-on Exercise 3-A",
    "section": "6.1 Customising Tooltip style",
    "text": "6.1 Customising Tooltip style\nCode chunk below uses opts_tooltip() of ggiraph to customize tooltip rendering by add css declarations.\n\nCodePlot\n\n\n\ntooltip_css &lt;- \"background-color:white; #&lt;&lt;\nfont-style:bold; color:black;\" #&lt;&lt;\n\np &lt;- ggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_dotplot_interactive(              \n    aes(tooltip = ID),                   \n    stackgroups = TRUE,                  \n    binwidth = 1,                        \n    method = \"histodot\") +               \n  scale_y_continuous(NULL,               \n                     breaks = NULL)\ngirafe(                                  \n  ggobj = p,                             \n  width_svg = 6,                         \n  height_svg = 6*0.618,\n  options = list(    #&lt;&lt;\n    opts_tooltip(    #&lt;&lt;\n      css = tooltip_css)) #&lt;&lt;\n)                                        \n\n\n\nNotice that the background colour of the tooltip is black and the font colour is white and bold.\n\n\n\n\n\n\n\n\n\nRefer to Customizing girafe objects to learn more about how to customise ggiraph objects."
  },
  {
    "objectID": "HE03.1.html#displaying-statistics-on-tooltip",
    "href": "HE03.1.html#displaying-statistics-on-tooltip",
    "title": "Hands-on Exercise 3-A",
    "section": "6.2 Displaying statistics on tooltip",
    "text": "6.2 Displaying statistics on tooltip\nThis section shows an advanced way to customise tooltip. In this example, a function is used to compute 90% confident interval of the mean. The derived statistics are then displayed in the tooltip.\n\nCodePlot\n\n\n\ntooltip &lt;- function(y, ymax, accuracy = .01) {\n  mean &lt;- scales::number(y, accuracy = accuracy)\n  sem &lt;- scales::number(ymax - y, accuracy = accuracy)\n  paste(\"Mean maths scores:\", mean, \"+/-\", sem)\n}\n\ngg_point &lt;- ggplot(data=exam_data, \n                   aes(x = RACE),\n) +\n  stat_summary(aes(y = MATHS, \n                   tooltip = after_stat(  \n                     tooltip(y, ymax))),  \n    fun.data = \"mean_se\", \n    geom = GeomInteractiveCol,  \n    fill = \"light blue\"\n  ) +\n  stat_summary(aes(y = MATHS),\n    fun.data = mean_se,\n    geom = \"errorbar\", width = 0.2, size = 0.2\n  )\n\ngirafe(ggobj = gg_point,\n       width_svg = 8,\n       height_svg = 8*0.618)"
  },
  {
    "objectID": "HE03.1.html#hover-effect-with-data_id-aesthetic",
    "href": "HE03.1.html#hover-effect-with-data_id-aesthetic",
    "title": "Hands-on Exercise 3-A",
    "section": "6.3 Hover effect with data_id aesthetic",
    "text": "6.3 Hover effect with data_id aesthetic\n\nCodePlot\n\n\nCode chunk below shows the second interactive feature of ggiraph, namely data_id.\n\np &lt;- ggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_dotplot_interactive(           \n    aes(data_id = CLASS),             \n    stackgroups = TRUE,               \n    binwidth = 1,                        \n    method = \"histodot\") +               \n  scale_y_continuous(NULL,               \n                     breaks = NULL)\ngirafe(                                  \n  ggobj = p,                             \n  width_svg = 6,                         \n  height_svg = 6*0.618                      \n)                                        \n\n\n\nInteractivity: Elements associated with a data_id (i.e CLASS) will be highlighted upon mouse over."
  },
  {
    "objectID": "HE03.1.html#styling-hover-effect",
    "href": "HE03.1.html#styling-hover-effect",
    "title": "Hands-on Exercise 3-A",
    "section": "6.4 Styling hover effect",
    "text": "6.4 Styling hover effect\n\nCodePlot\n\n\nIn this code chunk, css codes are used to change the highlighting effect.\n\np &lt;- ggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_dotplot_interactive(              \n    aes(data_id = CLASS),              \n    stackgroups = TRUE,                  \n    binwidth = 1,                        \n    method = \"histodot\") +               \n  scale_y_continuous(NULL,               \n                     breaks = NULL)\ngirafe(                                  \n  ggobj = p,                             \n  width_svg = 6,                         \n  height_svg = 6*0.618,\n  options = list(                        \n    opts_hover(css = \"fill: #202020;\"),  \n    opts_hover_inv(css = \"opacity:0.2;\") \n  )                                        \n)                                        \n\n\n\nInteractivity: Elements associated with a data_id (i.e CLASS) will be highlighted upon mouse over.\n\n\n\n\n\n\n\n\n\nNote: Different from previous example, in this example the ccs customisation request are encoded directly."
  },
  {
    "objectID": "HE03.1.html#combining-tooltip-and-hover-effect",
    "href": "HE03.1.html#combining-tooltip-and-hover-effect",
    "title": "Hands-on Exercise 3-A",
    "section": "6.5 Combining tooltip and hover effect",
    "text": "6.5 Combining tooltip and hover effect\nThere are times that we want to combine tooltip and hover effect on the interactive statistical graph as shown in the code chunk below.\n\nCodePlot\n\n\n\np &lt;- ggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_dotplot_interactive(              \n    aes(tooltip = CLASS, \n        data_id = CLASS),              \n    stackgroups = TRUE,                  \n    binwidth = 1,                        \n    method = \"histodot\") +               \n  scale_y_continuous(NULL,               \n                     breaks = NULL)\ngirafe(                                  \n  ggobj = p,                             \n  width_svg = 6,                         \n  height_svg = 6*0.618,\n  options = list(                        \n    opts_hover(css = \"fill: #202020;\"),  \n    opts_hover_inv(css = \"opacity:0.2;\") \n  )                                        \n)                                        \n\nInteractivity: Elements associated with a data_id (i.e CLASS) will be highlighted upon mouse over. At the same time, the tooltip will show the CLASS."
  },
  {
    "objectID": "HE03.1.html#click-effect-with-onclick",
    "href": "HE03.1.html#click-effect-with-onclick",
    "title": "Hands-on Exercise 3-A",
    "section": "6.6 Click effect with onclick",
    "text": "6.6 Click effect with onclick\nonclick argument of ggiraph provides hotlink interactivity on the web. The code chunk below shown an example of onclick.\n\nCodePlot\n\n\n\nexam_data$onclick &lt;- sprintf(\"window.open(\\\"%s%s\\\")\",\n\"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school\",\nas.character(exam_data$ID))\n\np &lt;- ggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_dotplot_interactive(              \n    aes(onclick = onclick),              \n    stackgroups = TRUE,                  \n    binwidth = 1,                        \n    method = \"histodot\") +               \n  scale_y_continuous(NULL,               \n                     breaks = NULL)\ngirafe(                                  \n  ggobj = p,                             \n  width_svg = 6,                         \n  height_svg = 6*0.618)                                        \n\n\n\nInteractivity: Web document link with a data object will be displayed on the web browser upon mouse click."
  },
  {
    "objectID": "HE03.1.html#coordinated-multiple-views-with-ggiraph",
    "href": "HE03.1.html#coordinated-multiple-views-with-ggiraph",
    "title": "Hands-on Exercise 3-A",
    "section": "6.7 Coordinated Multiple Views with ggiraph",
    "text": "6.7 Coordinated Multiple Views with ggiraph\nCoordinated multiple views methods has been implemented in the data visualisation below.\n\n\n\n\n\n\nNotice that when a data point in one of the dot plots is selected, the corresponding point with the same ID in the second visualization is also highlighted. To build such coordinated multiple views, the following approach is applied:\n\nUse the appropriate interactive functions from the ggiraph package to create multiple linked visualizations.\nIntegrate these plots using the patchwork package within the girafe() function to produce the interactive, coordinated view.\n\n\np1 &lt;- ggplot(data=exam_data, \n       aes(x = MATHS)) +\n  geom_dotplot_interactive(              \n    aes(data_id = ID),              \n    stackgroups = TRUE,                  \n    binwidth = 1,                        \n    method = \"histodot\") +  \n  coord_cartesian(xlim=c(0,100)) + \n  scale_y_continuous(NULL,               \n                     breaks = NULL)\n\np2 &lt;- ggplot(data=exam_data, \n       aes(x = ENGLISH)) +\n  geom_dotplot_interactive(              \n    aes(data_id = ID),              \n    stackgroups = TRUE,                  \n    binwidth = 1,                        \n    method = \"histodot\") + \n  coord_cartesian(xlim=c(0,100)) + \n  scale_y_continuous(NULL,               \n                     breaks = NULL)\n\ngirafe(code = print(p1 + p2), \n       width_svg = 6,\n       height_svg = 3,\n       options = list(\n         opts_hover(css = \"fill: #202020;\"),\n         opts_hover_inv(css = \"opacity:0.2;\")\n         )\n       ) \n\nThe data_id aesthetic is critical to link observations between plots and the tooltip aesthetic is optional but nice to have when mouse over a point."
  },
  {
    "objectID": "HE03.1.html#creating-an-interactive-scatter-plot-plot_ly-method",
    "href": "HE03.1.html#creating-an-interactive-scatter-plot-plot_ly-method",
    "title": "Hands-on Exercise 3-A",
    "section": "7.1 Creating an interactive scatter plot: plot_ly() method",
    "text": "7.1 Creating an interactive scatter plot: plot_ly() method\nThe tabset below shows an example a basic interactive plot created by using plot_ly().\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\nplot_ly(data = exam_data, \n             x = ~MATHS, \n             y = ~ENGLISH)"
  },
  {
    "objectID": "HE03.1.html#working-with-visual-variable-plot_ly-method",
    "href": "HE03.1.html#working-with-visual-variable-plot_ly-method",
    "title": "Hands-on Exercise 3-A",
    "section": "7.2 Working with visual variable: plot_ly() method",
    "text": "7.2 Working with visual variable: plot_ly() method\nIn the code chunk below, color argument is mapped to a qualitative visual variable (i.e. RACE).\n\nPlotCode\n\n\nInteractive: Click on the colour symbol at the legend.\n\n\n\n\n\n\n\n\n\nplot_ly(data = exam_data, \n        x = ~ENGLISH, \n        y = ~MATHS, \n        color = ~RACE)"
  },
  {
    "objectID": "HE03.1.html#creating-an-interactive-scatter-plot-ggplotly-method",
    "href": "HE03.1.html#creating-an-interactive-scatter-plot-ggplotly-method",
    "title": "Hands-on Exercise 3-A",
    "section": "7.3 Creating an interactive scatter plot: ggplotly() method",
    "text": "7.3 Creating an interactive scatter plot: ggplotly() method\nThe code chunk below plots an interactive scatter plot by using ggplotly().\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\np &lt;- ggplot(data=exam_data, \n            aes(x = MATHS,\n                y = ENGLISH)) +\n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\nggplotly(p)\n\nNotice that the only extra line you need to include in the code chunk is ggplotly()."
  },
  {
    "objectID": "HE03.1.html#coordinated-multiple-views-with-plotly",
    "href": "HE03.1.html#coordinated-multiple-views-with-plotly",
    "title": "Hands-on Exercise 3-A",
    "section": "7.4 Coordinated Multiple Views with plotly",
    "text": "7.4 Coordinated Multiple Views with plotly\nThe creation of a coordinated linked plot by using plotly involves three steps:\n\nhighlight_key() of plotly package is used as shared data.\ntwo scatterplots will be created by using ggplot2 functions.\nlastly, subplot() of plotly package is used to place them next to each other side-by-side.\n\n\nPlotCode\n\n\nClick on a data point of one of the scatterplot and see how the corresponding point on the other scatterplot is selected.\n\n\n\n\n\n\n\n\n\nd &lt;- highlight_key(exam_data)\np1 &lt;- ggplot(data=d, \n            aes(x = MATHS,\n                y = ENGLISH)) +\n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\n\np2 &lt;- ggplot(data=d, \n            aes(x = MATHS,\n                y = SCIENCE)) +\n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\nsubplot(ggplotly(p1),\n        ggplotly(p2))\n\n\n\n\nThings to learn from the code chunk:\n\nhighlight_key() simply creates an object of class crosstalk::SharedData.\nVisit this link to learn more about crosstalk,"
  },
  {
    "objectID": "HE03.1.html#interactive-data-table-dt-package",
    "href": "HE03.1.html#interactive-data-table-dt-package",
    "title": "Hands-on Exercise 3-A",
    "section": "8.1 Interactive Data Table: DT package",
    "text": "8.1 Interactive Data Table: DT package\n\nA wrapper of the JavaScript Library DataTables\nData objects in R can be rendered as HTML tables using the JavaScript library ‘DataTables’ (typically via R Markdown or Shiny).\n\n\nDT::datatable(exam_data, class= \"compact\")"
  },
  {
    "objectID": "HE03.1.html#linked-brushing-crosstalk-method",
    "href": "HE03.1.html#linked-brushing-crosstalk-method",
    "title": "Hands-on Exercise 3-A",
    "section": "8.2 Linked brushing: crosstalk method",
    "text": "8.2 Linked brushing: crosstalk method\nCode chunk below is used to implement coordinated brushing shown.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nd &lt;- highlight_key(exam_data) \np &lt;- ggplot(d, \n            aes(ENGLISH, \n                MATHS)) + \n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100),\n                  ylim=c(0,100))\n\ngg &lt;- highlight(ggplotly(p),        \n                \"plotly_selected\")  \n\ncrosstalk::bscols(gg,               \n                  DT::datatable(d), \n                  widths = 5)        \n\n\n\n\nThings to learn from the code chunk:\n\nhighlight() is a function of plotly package. It sets a variety of options for brushing (i.e., highlighting) multiple plots. These options are primarily designed for linking multiple plotly graphs, and may not behave as expected when linking plotly to another htmlwidget package via crosstalk. In some cases, other htmlwidgets will respect these options, such as persistent selection in leaflet.\nbscols() is a helper function of crosstalk package. It makes it easy to put HTML elements side by side. It can be called directly from the console but is especially designed to work in an R Markdown document. Warning: This will bring in all of Bootstrap!."
  },
  {
    "objectID": "HE03.1.html#ggiraph",
    "href": "HE03.1.html#ggiraph",
    "title": "Hands-on Exercise 3-A",
    "section": "9.1 ggiraph",
    "text": "9.1 ggiraph\nThis link provides online version of the reference guide and several useful articles. Use this link to download the pdf version of the reference guide.\n\nHow to Plot With Ggiraph\nInteractive map of France with ggiraph\nCustom interactive sunbursts with ggplot in R\nThis link provides code example on how ggiraph is used to interactive graphs for Swiss Olympians - the solo specialists."
  },
  {
    "objectID": "HE03.1.html#plotly-for-r",
    "href": "HE03.1.html#plotly-for-r",
    "title": "Hands-on Exercise 3-A",
    "section": "9.2 plotly for R",
    "text": "9.2 plotly for R\n\nGetting Started with Plotly in R\nA collection of plotly R graphs are available via this link.\nCarson Sievert (2020) Interactive web-based data visualization with R, plotly, and shiny, Chapman and Hall/CRC is the best resource to learn plotly for R. The online version is available via this link\nPlotly R Figure Reference provides a comprehensive discussion of each visual representations.\nPlotly R Library Fundamentals is a good place to learn the fundamental features of Plotly’s R API.\nGetting Started\nVisit this link for a very interesting implementation of gganimate by your senior.\nBuilding an animation step-by-step with gganimate.\nCreating a composite gif with multiple gganimate panels"
  },
  {
    "objectID": "HE03.2.html",
    "href": "HE03.2.html",
    "title": "Hands-on Exercise 3-B",
    "section": "",
    "text": "Animated graphics capture audience attention and leave stronger impressions than static visuals when telling data-driven stories. In this hands-on exercise, you’ll learn to create animated visualizations using the gganimate and plotly r packages, while also mastering (i) data reshaping with tidyr, and (ii) data processing and transformation with dplyr.\n\n\nWhen creating animations, the plot does not actually move. Instead, many individual plots are built and then stitched together as movie frames, just like an old-school flip book or cartoon. Each frame is a different plot when conveying motion, which is built using some relevant subset of the aggregate data. The subset drives the flow of the animation when stitched back together.\n\n\n\n\nBefore we dive into the steps for creating an animated statistical graph, it’s important to understand some of the key concepts and terminology related to this type of visualization.\n\nFrame: In an animated line graph, each frame represents a different point in time or a different category. When the frame changes, the data points on the graph are updated to reflect the new data.\nAnimation Attributes: The animation attributes are the settings that control how the animation behaves. For example, you can specify the duration of each frame, the easing function used to transition between frames, and whether to start the animation from the current frame or from the beginning."
  },
  {
    "objectID": "HE03.2.html#basic-concepts-of-animation",
    "href": "HE03.2.html#basic-concepts-of-animation",
    "title": "Hands-on Exercise 3-B",
    "section": "",
    "text": "When creating animations, the plot does not actually move. Instead, many individual plots are built and then stitched together as movie frames, just like an old-school flip book or cartoon. Each frame is a different plot when conveying motion, which is built using some relevant subset of the aggregate data. The subset drives the flow of the animation when stitched back together."
  },
  {
    "objectID": "HE03.2.html#terminology",
    "href": "HE03.2.html#terminology",
    "title": "Hands-on Exercise 3-B",
    "section": "",
    "text": "Before we dive into the steps for creating an animated statistical graph, it’s important to understand some of the key concepts and terminology related to this type of visualization.\n\nFrame: In an animated line graph, each frame represents a different point in time or a different category. When the frame changes, the data points on the graph are updated to reflect the new data.\nAnimation Attributes: The animation attributes are the settings that control how the animation behaves. For example, you can specify the duration of each frame, the easing function used to transition between frames, and whether to start the animation from the current frame or from the beginning."
  },
  {
    "objectID": "HE03.1.html",
    "href": "HE03.1.html",
    "title": "Hands-on Exercise 3-A",
    "section": "",
    "text": "This exercise discusses about creating interactive data visualisation by using functions provided by ggiraph and plotlyr packages."
  },
  {
    "objectID": "HE04.4.html",
    "href": "HE04.4.html",
    "title": "Hands-on Exercise 4-D",
    "section": "",
    "text": "Funnel plot is a specially designed data visualisation for conducting unbiased comparison between outlets, stores or business entities. This hands-on exercise helps in gaining hands-on experience in:\n\nplotting funnel plots by using funnelPlotR package,\nplotting static funnel plot by using ggplot2 package, and\nplotting interactive funnel plot by using both plotly R and ggplot2 packages."
  },
  {
    "objectID": "HE04.1.html",
    "href": "HE04.1.html",
    "title": "Hands-on Exercise 4-A",
    "section": "",
    "text": "The visualisation of distribution has long been a fundamental aspect of statistical analysis. In Chapter 1, several popular statistical graphic methods, including the histogram, probability density curve (PDF), boxplot, notch plot, and violin plot, were introduced and demonstrated using ggplot2. In this chapter, two relatively new statistical graphic methods for visualising distribution — the ridgeline plot and the raincloud plot — will be presented and created with ggplot2 and its extensions."
  },
  {
    "objectID": "HE04.1.html#installing-and-loading-the-packages",
    "href": "HE04.1.html#installing-and-loading-the-packages",
    "title": "Hands-on Exercise 4-A",
    "section": "2.1 Installing and loading the packages",
    "text": "2.1 Installing and loading the packages\nFor the purpose of this exercise, the following R packages will be used, they are:\n\nggridges, a ggplot2 extension specially designed for plotting ridgeline plots,\nggdist, a ggplot2 extension spacially desgin for visualising distribution and uncertainty,\ntidyverse, a family of R packages to meet the modern data science and visual communication needs,\nggthemes, a ggplot extension that provides the user additional themes, scales, and geoms for the ggplots package, and\ncolorspace, an R package provides a broad toolbox for selecting individual colors or color palettes, manipulating these colors, and employing them in various kinds of visualisations.\n\nThe code chunk below will be used load these R packages into RStudio environment.\n\npacman::p_load(ggdist, ggridges, ggthemes,\n               colorspace, tidyverse)"
  },
  {
    "objectID": "HE04.1.html#data-import",
    "href": "HE04.1.html#data-import",
    "title": "Hands-on Exercise 4-A",
    "section": "2.2 Data import",
    "text": "2.2 Data import\nFor the purpose of this exercise, Exam_data.csv will be used.\nIn the code chunk below, read_csv() of readr package is used to import Exam_data.csv into R and saved it into a tibble data.frame.\n\nexam &lt;- read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "HE04.1.html#plotting-ridgeline-graph-ggridges-method",
    "href": "HE04.1.html#plotting-ridgeline-graph-ggridges-method",
    "title": "Hands-on Exercise 4-A",
    "section": "3.1 Plotting ridgeline graph: ggridges method",
    "text": "3.1 Plotting ridgeline graph: ggridges method\nThere are several ways to plot ridgeline plot with R. In this section, you will learn how to plot ridgeline plot by using ggridges package.\nggridges package provides two main geom to plot gridgeline plots, they are: geom_ridgeline() and geom_density_ridges(). The former takes height values directly to draw the ridgelines, and the latter first estimates data densities and then draws those using ridgelines.\nThe ridgeline plot below is plotted by using geom_density_ridges().\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = ENGLISH, \n           y = CLASS)) +\n  geom_density_ridges(\n    scale = 3,\n    rel_min_height = 0.01,\n    bandwidth = 3.4,\n    fill = lighten(\"#7097BB\", .3),\n    color = \"white\"\n  ) +\n  scale_x_continuous(\n    name = \"English grades\",\n    expand = c(0, 0)\n    ) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()"
  },
  {
    "objectID": "HE04.1.html#varying-fill-colors-along-the-x-axis",
    "href": "HE04.1.html#varying-fill-colors-along-the-x-axis",
    "title": "Hands-on Exercise 4-A",
    "section": "3.2 Varying fill colors along the x axis",
    "text": "3.2 Varying fill colors along the x axis\nAt times, the area beneath a ridgeline may be preferred not to be filled with a single solid color but instead with colors that vary along the x-axis. This effect can be produced by using either geom_ridgeline_gradient() or geom_density_ridges_gradient(). Both geoms are used in the same way as geom_ridgeline() and geom_density_ridges(), except that variation in fill colors is permitted. However, alpha transparency in the fill is not supported. Due to technical limitations, either varying fill colors or transparency can be applied—but not both simultaneously.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = ENGLISH, \n           y = CLASS,\n           fill = stat(x))) +\n  geom_density_ridges_gradient(\n    scale = 3,\n    rel_min_height = 0.01) +\n  scale_fill_viridis_c(name = \"Temp. [F]\",\n                       option = \"C\") +\n  scale_x_continuous(\n    name = \"English grades\",\n    expand = c(0, 0)\n  ) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()"
  },
  {
    "objectID": "HE04.1.html#mapping-the-probabilities-directly-onto-colour",
    "href": "HE04.1.html#mapping-the-probabilities-directly-onto-colour",
    "title": "Hands-on Exercise 4-A",
    "section": "3.3 Mapping the probabilities directly onto colour",
    "text": "3.3 Mapping the probabilities directly onto colour\nBeside providing additional geom objects to support the need to plot ridgeline plot, ggridges package also provides a stat function called stat_density_ridges() that replaces stat_density() of ggplot2.\nFigure below is plotted by mapping the probabilities calculated by using stat(ecdf) which represent the empirical cumulative density function for the distribution of English score.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = 0.5 - abs(0.5-stat(ecdf)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\", \n                      calc_ecdf = TRUE) +\n  scale_fill_viridis_c(name = \"Tail probability\",\n                       direction = -1) +\n  theme_ridges()\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIt is important include the argument calc_ecdf = TRUE in stat_density_ridges()."
  },
  {
    "objectID": "HE04.1.html#ridgeline-plots-with-quantile-lines",
    "href": "HE04.1.html#ridgeline-plots-with-quantile-lines",
    "title": "Hands-on Exercise 4-A",
    "section": "3.4 Ridgeline plots with quantile lines",
    "text": "3.4 Ridgeline plots with quantile lines\nBy using geom_density_ridges_gradient(), we can colour the ridgeline plot by quantile, via the calculated stat(quantile) aesthetic as shown in the figure below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = factor(stat(quantile))\n           )) +\n  stat_density_ridges(\n    geom = \"density_ridges_gradient\",\n    calc_ecdf = TRUE, \n    quantiles = 4,\n    quantile_lines = TRUE) +\n  scale_fill_viridis_d(name = \"Quartiles\") +\n  theme_ridges()\n\n\n\n\nInstead of using number to define the quantiles, we can also specify quantiles by cut points such as 2.5% and 97.5% tails to colour the ridgeline plot as shown in the figure below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam,\n       aes(x = ENGLISH, \n           y = CLASS, \n           fill = factor(stat(quantile))\n           )) +\n  stat_density_ridges(\n    geom = \"density_ridges_gradient\",\n    calc_ecdf = TRUE, \n    quantiles = c(0.025, 0.975)\n    ) +\n  scale_fill_manual(\n    name = \"Probability\",\n    values = c(\"#FF0000A0\", \"#A0A0A0A0\", \"#0000FFA0\"),\n    labels = c(\"(0, 0.025]\", \"(0.025, 0.975]\", \"(0.975, 1]\")\n  ) +\n  theme_ridges()"
  },
  {
    "objectID": "HE04.1.html#plotting-a-half-eye-graph",
    "href": "HE04.1.html#plotting-a-half-eye-graph",
    "title": "Hands-on Exercise 4-A",
    "section": "4.1 Plotting a Half Eye graph",
    "text": "4.1 Plotting a Half Eye graph\nFirst, we will plot a Half-Eye graph by using stat_halfeye() of ggdist package.\nThis produces a Half Eye visualization, which is contains a half-density and a slab-interval.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA)"
  },
  {
    "objectID": "HE04.1.html#adding-the-boxplot-with-geom_boxplot",
    "href": "HE04.1.html#adding-the-boxplot-with-geom_boxplot",
    "title": "Hands-on Exercise 4-A",
    "section": "4.2 Adding the boxplot with geom_boxplot()",
    "text": "4.2 Adding the boxplot with geom_boxplot()\nNext, we will add the second geometry layer using geom_boxplot() of ggplot2. This produces a narrow boxplot. We reduce the width and adjust the opacity.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA)"
  },
  {
    "objectID": "HE04.1.html#adding-the-dot-plots-with-stat_dots",
    "href": "HE04.1.html#adding-the-dot-plots-with-stat_dots",
    "title": "Hands-on Exercise 4-A",
    "section": "4.3 Adding the Dot Plots with stat_dots()",
    "text": "4.3 Adding the Dot Plots with stat_dots()\nNext, we will add the third geometry layer using stat_dots() of ggdist package. This produces a half-dotplot, which is similar to a histogram that indicates the number of samples (number of dots) in each bin. We select side = “left” to indicate we want it on the left-hand side.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA) +\n  stat_dots(side = \"left\", \n            justification = 1.2, \n            binwidth = .5,\n            dotsize = 2)"
  },
  {
    "objectID": "HE04.1.html#finishing-touch",
    "href": "HE04.1.html#finishing-touch",
    "title": "Hands-on Exercise 4-A",
    "section": "4.4 Finishing touch",
    "text": "4.4 Finishing touch\nLastly, coord_flip() of ggplot2 package will be used to flip the raincloud chart horizontally to give it the raincloud appearance. At the same time, theme_economist() of ggthemes package is used to give the raincloud chart a professional publishing standard look.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, \n       aes(x = RACE, \n           y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5,\n               justification = -0.2,\n               .width = 0,\n               point_colour = NA) +\n  geom_boxplot(width = .20,\n               outlier.shape = NA) +\n  stat_dots(side = \"left\", \n            justification = 1.2, \n            binwidth = .5,\n            dotsize = 1.5) +\n  coord_flip() +\n  theme_economist()"
  },
  {
    "objectID": "HE04.2.html",
    "href": "HE04.2.html",
    "title": "Hands-on Exercise 4-B",
    "section": "",
    "text": "In this hands-on exercise, you will gain hands-on experience on using:\n\nggstatsplot package to create visual graphics with rich statistical information,\nperformance package to visualise model diagnostics,\nand parameters package to visualise model parameters"
  },
  {
    "objectID": "HE04.2.html#installing-and-launching-r-packages",
    "href": "HE04.2.html#installing-and-launching-r-packages",
    "title": "Hands-on Exercise 4-B",
    "section": "3.1 Installing and launching R packages",
    "text": "3.1 Installing and launching R packages\nIn this exercise, ggstatsplot and tidyverse will be used.\n\npacman::p_load(ggstatsplot, tidyverse)"
  },
  {
    "objectID": "HE04.2.html#importing-data",
    "href": "HE04.2.html#importing-data",
    "title": "Hands-on Exercise 4-B",
    "section": "3.2 Importing data",
    "text": "3.2 Importing data\n\nexam &lt;- read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "HE04.2.html#one-sample-test-gghistostats-method",
    "href": "HE04.2.html#one-sample-test-gghistostats-method",
    "title": "Hands-on Exercise 4-B",
    "section": "3.3 One-sample test: gghistostats() method",
    "text": "3.3 One-sample test: gghistostats() method\nIn the code chunk below, gghistostats() is used to to build an visual of one-sample test on English scores.\n\nset.seed(1234)\n\ngghistostats(\n  data = exam,\n  x = ENGLISH,\n  type = \"bayes\",\n  test.value = 60,\n  xlab = \"English scores\"\n)\n\n\n\n\n\n\n\n\nDefault information: - statistical details - Bayes Factor - sample sizes - distribution summary"
  },
  {
    "objectID": "HE04.2.html#unpacking-the-bayes-factor",
    "href": "HE04.2.html#unpacking-the-bayes-factor",
    "title": "Hands-on Exercise 4-B",
    "section": "3.4 Unpacking the Bayes Factor",
    "text": "3.4 Unpacking the Bayes Factor\n\nA Bayes factor is the ratio of the likelihood of one particular hypothesis to the likelihood of another. It can be interpreted as a measure of the strength of evidence in favor of one theory among two competing theories.\nThat’s because the Bayes factor gives us a way to evaluate the data in favor of a null hypothesis, and to use external information to do so. It tells us what the weight of the evidence is in favor of a given hypothesis.\nWhen we are comparing two hypotheses, H1 (the alternate hypothesis) and H0 (the null hypothesis), the Bayes Factor is often written as B10. It can be defined mathematically as\n\nThe Schwarz criterion is one of the easiest ways to calculate rough approximation of the Bayes Factor."
  },
  {
    "objectID": "HE04.2.html#how-to-interpret-bayes-factor",
    "href": "HE04.2.html#how-to-interpret-bayes-factor",
    "title": "Hands-on Exercise 4-B",
    "section": "3.5 How to interpret Bayes Factor",
    "text": "3.5 How to interpret Bayes Factor\nA Bayes Factor can be any positive number. One of the most common interpretations is this one—first proposed by Harold Jeffereys (1961) and slightly modified by Lee and Wagenmakers in 2013:"
  },
  {
    "objectID": "HE04.2.html#two-sample-mean-test-ggbetweenstats",
    "href": "HE04.2.html#two-sample-mean-test-ggbetweenstats",
    "title": "Hands-on Exercise 4-B",
    "section": "3.6 Two-sample mean test: ggbetweenstats()",
    "text": "3.6 Two-sample mean test: ggbetweenstats()\nIn the code chunk below, ggbetweenstats() is used to build a visual for two-sample mean test of Maths scores by gender.\n\nggbetweenstats(\n  data = exam,\n  x = GENDER, \n  y = MATHS,\n  type = \"np\",\n  messages = FALSE\n)\n\n\n\n\n\n\n\n\nDefault information: - statistical details - Bayes Factor - sample sizes - distribution summary"
  },
  {
    "objectID": "HE04.2.html#oneway-anova-test-ggbetweenstats-method",
    "href": "HE04.2.html#oneway-anova-test-ggbetweenstats-method",
    "title": "Hands-on Exercise 4-B",
    "section": "3.7 Oneway ANOVA Test: ggbetweenstats() method",
    "text": "3.7 Oneway ANOVA Test: ggbetweenstats() method\nIn the code chunk below, ggbetweenstats() is used to build a visual for One-way ANOVA test on English score by race.\n\nggbetweenstats(\n  data = exam,\n  x = RACE, \n  y = ENGLISH,\n  type = \"p\",\n  mean.ci = TRUE, \n  pairwise.comparisons = TRUE, \n  pairwise.display = \"s\",\n  p.adjust.method = \"fdr\",\n  messages = FALSE\n)\n\n\n\n\n\n\n\n\n\n“ns” → only non-significant\n“s” → only significant\n“all” → everything"
  },
  {
    "objectID": "HE04.2.html#significant-test-of-correlation-ggscatterstats",
    "href": "HE04.2.html#significant-test-of-correlation-ggscatterstats",
    "title": "Hands-on Exercise 4-B",
    "section": "3.8 Significant Test of Correlation: ggscatterstats()",
    "text": "3.8 Significant Test of Correlation: ggscatterstats()\nIn the code chunk below, ggscatterstats() is used to build a visual for Significant Test of Correlation between Maths scores and English scores.\n\nggscatterstats(\n  data = exam,\n  x = MATHS,\n  y = ENGLISH,\n  marginal = FALSE,\n  )"
  },
  {
    "objectID": "HE04.2.html#significant-test-of-association-depedence-ggbarstats-methods",
    "href": "HE04.2.html#significant-test-of-association-depedence-ggbarstats-methods",
    "title": "Hands-on Exercise 4-B",
    "section": "3.9 Significant Test of Association (Depedence) : ggbarstats() methods",
    "text": "3.9 Significant Test of Association (Depedence) : ggbarstats() methods\nIn the code chunk below, the Maths scores is binned into a 4-class variable by using cut().\n\nexam1 &lt;- exam %&gt;% \n  mutate(MATHS_bins = \n           cut(MATHS, \n               breaks = c(0,60,75,85,100))\n)\n\nIn this code chunk below ggbarstats() is used to build a visual for Significant Test of Association\n\nggbarstats(exam1, \n           x = MATHS_bins, \n           y = GENDER)"
  },
  {
    "objectID": "HE04.3.html",
    "href": "HE04.3.html",
    "title": "Hands-on Exercise 4-C",
    "section": "",
    "text": "The visualisation of uncertainty is considered a relatively new development in statistical graphics. In this chapter, hands-on experience will be provided in creating statistical graphics for visualising uncertainty. By the end of the chapter, the following skills will have been acquired:\n\nStatistical error bars will be plotted using ggplot2.\nInteractive error bars will be plotted by combining ggplot2, plotly, and DT.\nAdvanced visualisations will be created using ggdist.\nHypothetical outcome plots (HOPs) will be produced using the ungeviz package."
  },
  {
    "objectID": "HE04.3.html#installing-and-loading-the-packages",
    "href": "HE04.3.html#installing-and-loading-the-packages",
    "title": "Hands-on Exercise 4-C",
    "section": "2.1 Installing and loading the packages",
    "text": "2.1 Installing and loading the packages\nFor the purpose of this exercise, the following R packages will be used, they are:\n\ntidyverse, a family of R packages for data science process,\nplotly for creating interactive plot,\ngganimate for creating animation plot,\nDT for displaying interactive html table,\ncrosstalk for for implementing cross-widget interactions (currently, linked brushing and filtering), and\nggdist for visualising distribution and uncertainty.\n\n\npacman::p_load(plotly, crosstalk, DT, \n               ggdist, ggridges, colorspace,\n               gganimate, tidyverse)"
  },
  {
    "objectID": "HE04.3.html#data-import",
    "href": "HE04.3.html#data-import",
    "title": "Hands-on Exercise 4-C",
    "section": "2.2 Data import",
    "text": "2.2 Data import\nFor the purpose of this exercise, Exam_data.csv will be used.\n\nexam &lt;- read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "HE04.3.html#plotting-standard-error-bars-of-point-estimates",
    "href": "HE04.3.html#plotting-standard-error-bars-of-point-estimates",
    "title": "Hands-on Exercise 4-C",
    "section": "3.1 Plotting standard error bars of point estimates",
    "text": "3.1 Plotting standard error bars of point estimates\nNow we are ready to plot the standard error bars of mean maths score by race as shown below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(my_sum) +\n  geom_errorbar(\n    aes(x=RACE, \n        ymin=mean-se, \n        ymax=mean+se), \n    width=0.2, \n    colour=\"black\", \n    alpha=0.9, \n    linewidth=0.5) +\n  geom_point(aes\n           (x=RACE, \n            y=mean), \n           stat=\"identity\", \n           color=\"red\",\n           size = 1.5,\n           alpha=1) +\n  ggtitle(\"Standard error of mean maths score by rac\")\n\n\n\n\n\n\n\nNoteThings to learn from the code chunk\n\n\n\n\nThe error bars are computed by using the formula mean+/-se.\nFor geom_point(), it is important to indicate stat=“identity”."
  },
  {
    "objectID": "HE04.3.html#plotting-confidence-interval-of-point-estimates",
    "href": "HE04.3.html#plotting-confidence-interval-of-point-estimates",
    "title": "Hands-on Exercise 4-C",
    "section": "3.2 Plotting confidence interval of point estimates",
    "text": "3.2 Plotting confidence interval of point estimates\nInstead of plotting the standard error bar of point estimates, we can also plot the confidence intervals of mean maths score by race.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(my_sum) +\n  geom_errorbar(\n    aes(x=reorder(RACE, -mean), \n        ymin=mean-1.96*se, \n        ymax=mean+1.96*se), \n    width=0.2, \n    colour=\"black\", \n    alpha=0.9, \n    linewidth=0.5) +\n  geom_point(aes\n           (x=RACE, \n            y=mean), \n           stat=\"identity\", \n           color=\"red\",\n           size = 1.5,\n           alpha=1) +\n  labs(x = \"Maths score\",\n       title = \"95% confidence interval of mean maths score by race\")\n\n\n\n\n\n\n\nNoteThings to learn from the code chunk\n\n\n\n\nThe confidence intervals are computed by using the formula mean+/-1.96*se.\nThe error bars is sorted by using the average maths scores.\nlabs() argument of ggplot2 is used to change the x-axis label."
  },
  {
    "objectID": "HE04.3.html#visualising-the-uncertainty-of-point-estimates-with-interactive-error-bars",
    "href": "HE04.3.html#visualising-the-uncertainty-of-point-estimates-with-interactive-error-bars",
    "title": "Hands-on Exercise 4-C",
    "section": "3.3 Visualising the uncertainty of point estimates with interactive error bars",
    "text": "3.3 Visualising the uncertainty of point estimates with interactive error bars\nIn this section, you will learn how to plot interactive error bars for the 99% confidence interval of mean maths score by race as shown in the figure below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nshared_df = SharedData$new(my_sum)\n\nbscols(widths = c(4,8),\n       ggplotly((ggplot(shared_df) +\n                   geom_errorbar(aes(\n                     x=reorder(RACE, -mean),\n                     ymin=mean-2.58*se, \n                     ymax=mean+2.58*se), \n                     width=0.2, \n                     colour=\"black\", \n                     alpha=0.9, \n                     size=0.5) +\n                   geom_point(aes(\n                     x=RACE, \n                     y=mean, \n                     text = paste(\"Race:\", `RACE`, \n                                  \"&lt;br&gt;N:\", `n`,\n                                  \"&lt;br&gt;Avg. Scores:\", round(mean, digits = 2),\n                                  \"&lt;br&gt;95% CI:[\", \n                                  round((mean-2.58*se), digits = 2), \",\",\n                                  round((mean+2.58*se), digits = 2),\"]\")),\n                     stat=\"identity\", \n                     color=\"red\", \n                     size = 1.5, \n                     alpha=1) + \n                   xlab(\"Race\") + \n                   ylab(\"Average Scores\") + \n                   theme_minimal() + \n                   theme(axis.text.x = element_text(\n                     angle = 45, vjust = 0.5, hjust=1)) +\n                   ggtitle(\"99% Confidence interval of average /&lt;br&gt;maths scores by race\")), \n                tooltip = \"text\"), \n       DT::datatable(shared_df, \n                     rownames = FALSE, \n                     class=\"compact\", \n                     width=\"100%\", \n                     options = list(pageLength = 10,\n                                    scrollX=T), \n                     colnames = c(\"No. of pupils\", \n                                  \"Avg Scores\",\n                                  \"Std Dev\",\n                                  \"Std Error\")) %&gt;%\n         formatRound(columns=c('mean', 'sd', 'se'),\n                     digits=2))"
  },
  {
    "objectID": "HE04.3.html#visualising-the-uncertainty-of-point-estimates-ggdist-methods",
    "href": "HE04.3.html#visualising-the-uncertainty-of-point-estimates-ggdist-methods",
    "title": "Hands-on Exercise 4-C",
    "section": "4.1 Visualising the uncertainty of point estimates: ggdist methods",
    "text": "4.1 Visualising the uncertainty of point estimates: ggdist methods"
  },
  {
    "objectID": "HE04.3.html#installing-ungeviz-package",
    "href": "HE04.3.html#installing-ungeviz-package",
    "title": "Hands-on Exercise 4-C",
    "section": "5.1 Installing ungeviz package",
    "text": "5.1 Installing ungeviz package"
  },
  {
    "objectID": "HE04.3.html#launch-the-application-in-r",
    "href": "HE04.3.html#launch-the-application-in-r",
    "title": "Hands-on Exercise 4-C",
    "section": "5.2 Launch the application in R",
    "text": "5.2 Launch the application in R"
  },
  {
    "objectID": "HE04.3.html#visualising-uncertainty-with-hypothetical-outcome-plots-hops-1",
    "href": "HE04.3.html#visualising-uncertainty-with-hypothetical-outcome-plots-hops-1",
    "title": "Hands-on Exercise 4-C",
    "section": "5.1 Visualising Uncertainty with Hypothetical Outcome Plots (HOPs)",
    "text": "5.1 Visualising Uncertainty with Hypothetical Outcome Plots (HOPs)\nNext, the code chunk below will be used to build the HOPs.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data = exam, \n       (aes(x = factor(RACE), \n            y = MATHS))) +\n  geom_point(position = position_jitter(\n    height = 0.3, \n    width = 0.05), \n    size = 0.4, \n    color = \"#0072B2\", \n    alpha = 1/2) +\n  geom_hpline(data = sampler(25, \n                             group = RACE), \n              height = 0.6, \n              color = \"#D55E00\") +\n  theme_bw() + \n  transition_states(.draw, 1, 3)"
  },
  {
    "objectID": "HE04.3.html#visualising-the-uncertainty-of-point-estimates-using-stat_pointinterval",
    "href": "HE04.3.html#visualising-the-uncertainty-of-point-estimates-using-stat_pointinterval",
    "title": "Hands-on Exercise 4-C",
    "section": "4.1 Visualising the uncertainty of point estimates: using stat_pointinterval()",
    "text": "4.1 Visualising the uncertainty of point estimates: using stat_pointinterval()\nIn the code chunk below, stat_pointinterval() of ggdist is used to build a visual for displaying distribution of maths scores by race.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_pointinterval() +\n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Mean Point + Multiple-interval plot\")\n\n\n\n\nFor example, in the code chunk below the following arguments are used:\n\n.width = 0.95\n.point = median\n.interval = qi\n\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexam %&gt;%\n  ggplot(aes(x = RACE, y = MATHS)) +\n  stat_pointinterval(.width = 0.95,\n  .point = median,\n  .interval = qi) +\n  labs(\n    title = \"Visualising confidence intervals of median math score\",\n    subtitle = \"Median Point + Multiple-interval plot\")\n\n\n\n\nNext, the 95% and 99% confidence intervals are shown.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_pointinterval(\n    show.legend = FALSE) +   \n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Mean Point + Multiple-interval plot\")"
  },
  {
    "objectID": "HE04.3.html#visualising-the-uncertainty-of-point-estimates-using-stat_gradientinterval",
    "href": "HE04.3.html#visualising-the-uncertainty-of-point-estimates-using-stat_gradientinterval",
    "title": "Hands-on Exercise 4-C",
    "section": "4.2 Visualising the uncertainty of point estimates: using stat_gradientinterval()",
    "text": "4.2 Visualising the uncertainty of point estimates: using stat_gradientinterval()\nIn the code chunk below, stat_gradientinterval() of ggdist is used to build a visual for displaying distribution of maths scores by race.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_gradientinterval(   \n    fill = \"skyblue\",      \n    show.legend = TRUE     \n  ) +                        \n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Gradient + interval plot\")"
  },
  {
    "objectID": "HE04.4.html#installing-and-launching-r-packages",
    "href": "HE04.4.html#installing-and-launching-r-packages",
    "title": "Hands-on Exercise 4-D",
    "section": "2.1 Installing and Launching R Packages",
    "text": "2.1 Installing and Launching R Packages\nIn this exercise, four R packages will be used. They are:\n\nreadr for importing csv into R.\nFunnelPlotR for creating funnel plot.\nggplot2 for creating funnel plot manually.\nknitr for building static html table.\nplotly for creating interactive funnel plot.\n\n\npacman::p_load(tidyverse, FunnelPlotR, plotly, knitr)"
  },
  {
    "objectID": "HE04.4.html#importing-data",
    "href": "HE04.4.html#importing-data",
    "title": "Hands-on Exercise 4-D",
    "section": "2.2 Importing Data",
    "text": "2.2 Importing Data\nIn this section, COVID-19_DKI_Jakarta will be used. The data was downloaded from Open Data Covid-19 Provinsi DKI Jakarta portal. For this exercise, the comparison of the cumulative COVID-19 cases and death by sub-district (i.e. Kelurahan) as at 31st July 2021, DKI Jakarta.\nThe code chunk below imports the data into R and save it into a tibble data frame object called covid19.\n\ncovid19 &lt;- read_csv(\"COVID-19_DKI_Jakarta.csv\") %&gt;%\n  mutate_if(is.character, as.factor)"
  },
  {
    "objectID": "HE04.4.html#funnelplotr-methods-the-basic-plot",
    "href": "HE04.4.html#funnelplotr-methods-the-basic-plot",
    "title": "Hands-on Exercise 4-D",
    "section": "3.1 FunnelPlotR methods: The basic plot",
    "text": "3.1 FunnelPlotR methods: The basic plot\nThe code chunk below plots a funnel plot.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 0 are outliers. \nPlot is adjusted for overdispersion. \n\n\n\n\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Positive,\n  denominator = Death,\n  group = `Sub-district`\n)\n\n\n\n\n\n\n\nNoteThings to learn from the code chunk\n\n\n\n\ngroup in this function is different from the scatterplot. Here, it defines the level of the points to be plotted i.e. Sub-district, District or City. If City is chosen, there are only six data points.\nBy default, data_type argument is “SR”.\nlimit: Plot limits, accepted values are: 95 or 99, corresponding to 95% or 99.8% quantiles of the distribution."
  },
  {
    "objectID": "HE04.4.html#funnelplotr-methods-makeover-1",
    "href": "HE04.4.html#funnelplotr-methods-makeover-1",
    "title": "Hands-on Exercise 4-D",
    "section": "3.2 FunnelPlotR methods: Makeover 1",
    "text": "3.2 FunnelPlotR methods: Makeover 1\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\n\n\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Death,\n  denominator = Positive,\n  group = `Sub-district`,\n  data_type = \"PR\",     #&lt;&lt;\n  xrange = c(0, 6500),  #&lt;&lt;\n  yrange = c(0, 0.05)   #&lt;&lt;\n)\n\n\n\n\n\n\n\nNoteThings to learn from the code chunk\n\n\n\n\ndata_type argument is used to change from default “SR” to “PR” (i.e. proportions). xrange and yrange are used to set the range of x-axis and y-axis"
  },
  {
    "objectID": "HE04.4.html#funnelplotr-methods-makeover-2",
    "href": "HE04.4.html#funnelplotr-methods-makeover-2",
    "title": "Hands-on Exercise 4-D",
    "section": "3.3 FunnelPlotR methods: Makeover 2",
    "text": "3.3 FunnelPlotR methods: Makeover 2\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\n\n\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Death,\n  denominator = Positive,\n  group = `Sub-district`,\n  data_type = \"PR\",   \n  xrange = c(0, 6500),  \n  yrange = c(0, 0.05),\n  label = NA,\n  title = \"Cumulative COVID-19 Fatality Rate by Cumulative Total Number of COVID-19 Positive Cases\", #&lt;&lt;           \n  x_label = \"Cumulative COVID-19 Positive Cases\", #&lt;&lt;\n  y_label = \"Cumulative Fatality Rate\"  #&lt;&lt;\n)\n\n\n\n\n\n\n\nNoteThings to learn from the code chunk above.\n\n\n\n\nlabel = NA argument is to removed the default label outliers feature.\ntitle argument is used to add plot title.\nx_label and y_label arguments are used to add/edit x-axis and y-axis titles."
  },
  {
    "objectID": "HE04.4.html#computing-the-basic-derived-fields",
    "href": "HE04.4.html#computing-the-basic-derived-fields",
    "title": "Hands-on Exercise 4-D",
    "section": "4.1 Computing the basic derived fields",
    "text": "4.1 Computing the basic derived fields\nTo plot the funnel plot from scratch, we need to derive cumulative death rate and standard error of cumulative death rate.\n\ndf &lt;- covid19 %&gt;%\n  mutate(rate = Death / Positive) %&gt;%\n  mutate(rate.se = sqrt((rate*(1-rate)) / (Positive))) %&gt;%\n  filter(rate &gt; 0)\n\nNext, the fit.mean is computed by using the code chunk below.\n\nfit.mean &lt;- weighted.mean(df$rate, 1/df$rate.se^2)"
  },
  {
    "objectID": "HE04.4.html#calculate-lower-and-upper-limits-for-95-and-99.9-ci",
    "href": "HE04.4.html#calculate-lower-and-upper-limits-for-95-and-99.9-ci",
    "title": "Hands-on Exercise 4-D",
    "section": "4.2 Calculate lower and upper limits for 95% and 99.9% CI",
    "text": "4.2 Calculate lower and upper limits for 95% and 99.9% CI\nThe code chunk below is used to compute the lower and upper limits for 95% confidence interval.\n\nnumber.seq &lt;- seq(1, max(df$Positive), 1)\nnumber.ll95 &lt;- fit.mean - 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul95 &lt;- fit.mean + 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ll999 &lt;- fit.mean - 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul999 &lt;- fit.mean + 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \ndfCI &lt;- data.frame(number.ll95, number.ul95, number.ll999, \n                   number.ul999, number.seq, fit.mean)"
  },
  {
    "objectID": "HE04.4.html#plotting-a-static-funnel-plot",
    "href": "HE04.4.html#plotting-a-static-funnel-plot",
    "title": "Hands-on Exercise 4-D",
    "section": "4.3 Plotting a static funnel plot",
    "text": "4.3 Plotting a static funnel plot\nIn the code chunk below, ggplot2 functions are used to plot a static funnel plot.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np &lt;- ggplot(df, aes(x = Positive, y = rate)) +\n  geom_point(aes(label=`Sub-district`), \n             alpha=0.4) +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll95), \n            size = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul95), \n            size = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll999), \n            size = 0.4, \n            colour = \"grey40\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul999), \n            size = 0.4, \n            colour = \"grey40\") +\n  geom_hline(data = dfCI, \n             aes(yintercept = fit.mean), \n             size = 0.4, \n             colour = \"grey40\") +\n  coord_cartesian(ylim=c(0,0.05)) +\n  annotate(\"text\", x = 1, y = -0.13, label = \"95%\", size = 3, colour = \"grey40\") + \n  annotate(\"text\", x = 4.5, y = -0.18, label = \"99%\", size = 3, colour = \"grey40\") + \n  ggtitle(\"Cumulative Fatality Rate by Cumulative Number of COVID-19 Cases\") +\n  xlab(\"Cumulative Number of COVID-19 Cases\") + \n  ylab(\"Cumulative Fatality Rate\") +\n  theme_light() +\n  theme(plot.title = element_text(size=12),\n        legend.position = c(0.91,0.85), \n        legend.title = element_text(size=7),\n        legend.text = element_text(size=7),\n        legend.background = element_rect(colour = \"grey60\", linetype = \"dotted\"),\n        legend.key.height = unit(0.3, \"cm\"))\np"
  },
  {
    "objectID": "HE04.4.html#interactive-funnel-plot-plotly-ggplot2",
    "href": "HE04.4.html#interactive-funnel-plot-plotly-ggplot2",
    "title": "Hands-on Exercise 4-D",
    "section": "4.4 Interactive Funnel Plot: plotly + ggplot2",
    "text": "4.4 Interactive Funnel Plot: plotly + ggplot2\nThe funnel plot created using ggplot2 functions can be made interactive with ggplotly() of plotly r package.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\nfp_ggplotly &lt;- ggplotly(p,\n  tooltip = c(\"label\", \n              \"x\", \n              \"y\"))\nfp_ggplotly"
  },
  {
    "objectID": "HE05.1.html#the-data",
    "href": "HE05.1.html#the-data",
    "title": "Hands-on Exercise 5-A",
    "section": "3.1 The data",
    "text": "3.1 The data\nFor the purpose of this hands-on exercise, the Singapore Residents by Planning AreaSubzone, Age Group, Sex and Type of Dwelling, June 2000-2018 data will be used. The dataset is called respopagsex2000to2018_tidy.csv and is in csv file format."
  },
  {
    "objectID": "HE05.1.html#importing-data",
    "href": "HE05.1.html#importing-data",
    "title": "Hands-on Exercise 5-A",
    "section": "3.2 Importing Data",
    "text": "3.2 Importing Data\nTo important respopagsex2000to2018_tidy.csv into R, read_csv() function of readr package will be used.\n\npop_data &lt;- read_csv(\"data/respopagsex2000to2018_tidy.csv\")"
  },
  {
    "objectID": "HE05.1.html#preparing-the-data",
    "href": "HE05.1.html#preparing-the-data",
    "title": "Hands-on Exercise 5-A",
    "section": "3.3 Preparing the Data",
    "text": "3.3 Preparing the Data\nNext, use the mutate() function of dplyr package to derive three new measures, namely: young, active, and old.\n\n#Deriving the young, economy active and old measures\nagpop_mutated &lt;- pop_data %&gt;%\n  mutate(`Year` = as.character(Year))%&gt;%\n  spread(AG, Population) %&gt;%\n  mutate(YOUNG = rowSums(.[4:8]))%&gt;%\n  mutate(ACTIVE = rowSums(.[9:16]))  %&gt;%\n  mutate(OLD = rowSums(.[17:21])) %&gt;%\n  mutate(TOTAL = rowSums(.[22:24])) %&gt;%\n  filter(Year == 2018)%&gt;%\n  filter(TOTAL &gt; 0)"
  },
  {
    "objectID": "HE05.1.html#plotting-a-static-ternary-diagram",
    "href": "HE05.1.html#plotting-a-static-ternary-diagram",
    "title": "Hands-on Exercise 5-A",
    "section": "4.1 Plotting a static ternary diagram",
    "text": "4.1 Plotting a static ternary diagram\nUse ggtern() function of ggtern package to create a simple ternary plot.\n\n#Building the static ternary plot\n#| fig-align: \"center\"\nggtern(data=agpop_mutated,aes(x=YOUNG,y=ACTIVE, z=OLD)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n#Building the static ternary plot\nggtern(data=agpop_mutated, aes(x=YOUNG,y=ACTIVE, z=OLD)) +\n  geom_point() +\n  labs(title=\"Population structure, 2015\") +\n  theme_rgbw()"
  },
  {
    "objectID": "HE05.1.html#plotting-an-interative-ternary-diagram",
    "href": "HE05.1.html#plotting-an-interative-ternary-diagram",
    "title": "Hands-on Exercise 5-A",
    "section": "4.2 Plotting an interative ternary diagram",
    "text": "4.2 Plotting an interative ternary diagram\nThe code below create an interactive ternary plot using plot_ly() function of Plotly R.\n\nlabel &lt;- function(txt) {\n  list(\n    text = txt, \n    x = 0.1, y = 1,\n    ax = 0, ay = 0,\n    xref = \"paper\", yref = \"paper\", \n    align = \"center\",\n    font = list(family = \"serif\", size = 15, color = \"white\"),\n    bgcolor = \"#b3b3b3\", bordercolor = \"black\", borderwidth = 2\n  )\n}\n\n# reusable function for axis formatting\naxis &lt;- function(txt) {\n  list(\n    title = txt, tickformat = \".0%\", tickfont = list(size = 10)\n  )\n}\n\nternaryAxes &lt;- list(\n  aaxis = axis(\"Young\"), \n  baxis = axis(\"Active\"), \n  caxis = axis(\"Old\")\n)\n\n# Initiating a plotly visualization \nplot_ly(\n  agpop_mutated, \n  a = ~YOUNG, \n  b = ~ACTIVE, \n  c = ~OLD, \n  color = I(\"black\"), \n  type = \"scatterternary\"\n) %&gt;%\n  layout(\n    annotations = label(\"Ternary Markers\"), \n    ternary = ternaryAxes\n  )"
  },
  {
    "objectID": "HE05.1.html",
    "href": "HE05.1.html",
    "title": "Hands-on Exercise 5-A",
    "section": "",
    "text": "The distribution and variability of three-part compositional data can be shown using ternary charts. (For instance, the percentage of young, economically active, and elderly people, or the amount of clay, silt, and sand in the soil.) A triangle with sides scaled from 0 to 1 is what it displays. One of the three elements is represented by each side. Plotting a point involves making sure that a line drawn perpendicular to each leg of the triangle intersects at the point’s component values.\nThis hands-on focuses on how to use R to programmatically create ternary plots for visualising and understanding Singapore’s demographic structure. It consists of four steps:\n\nInstall and launch tidyverse and ggtern packages.\nDerive three new measures using mutate() function of dplyr package.\nBuild a static ternary plot using ggtern() function of ggtern package.\nBuild an interactive ternary plot using plot-ly() function of Plotly R package."
  },
  {
    "objectID": "HE05.2.html",
    "href": "HE05.2.html",
    "title": "Hands-on Exercise 5-B",
    "section": "",
    "text": "The correlation coefficient is a standard metric used to quantify the nature and intensity of the relationship between two variables. These values are bounded between -1.0 and 1.0:\n\n1.0: Represents a perfect positive linear relationship.\n-1.0: Represents a perfect inverse (negative) relationship.\n0.0: Indicates that no linear relationship exists between the variables.\n\n\n\n\nWhen working with multivariate data, these coefficients are typically organized into a table known as a correlation matrix or visualized via a scatterplot matrix.\nWhy Use a Correlation Matrix?\n\nExploratory Analysis: It reveals pairwise relationships within high-dimensional datasets.\nModel Input: It serves as the foundation for complex statistical techniques, such as Exploratory Factor Analysis (EFA), Structural Equation Modeling (SEM), and linear regressions.\nDiagnostics: It acts as a health check for other models. For instance, excessively high correlations in a linear regression can signal multicollinearity, making estimates unreliable.\n\n\n\n\nWhen datasets contain a high volume of observations or variables, a Corrgram is often used to detect patterns and structures. It operates on two primary principles:\n\nVisual Rendering: Mapping the sign and magnitude of correlations to specific colors or shapes.\nVariable Reordering: Grouping “similar” variables together to make clusters and relationships easier to perceive.\n\nThis hands-on exercise explores visualising correlation matrix with R. It consists of first creating matrices using the pairs() function, generating advanced corrgrams with the corrplot package, then finally building dynamic, interactive correlation matrices using plotly."
  },
  {
    "objectID": "HE05.2.html#understanding-the-correlation-coefficient",
    "href": "HE05.2.html#understanding-the-correlation-coefficient",
    "title": "Hands-on Exercise 5-B",
    "section": "",
    "text": "The correlation coefficient is a standard metric used to quantify the nature and intensity of the relationship between two variables. These values are bounded between -1.0 and 1.0:\n\n1.0: Represents a perfect positive linear relationship.\n-1.0: Represents a perfect inverse (negative) relationship.\n0.0: Indicates that no linear relationship exists between the variables."
  },
  {
    "objectID": "HE05.2.html#the-correlation-matrix",
    "href": "HE05.2.html#the-correlation-matrix",
    "title": "Hands-on Exercise 5-B",
    "section": "",
    "text": "When working with multivariate data, these coefficients are typically organized into a table known as a correlation matrix or visualized via a scatterplot matrix.\nWhy Use a Correlation Matrix?\n\nExploratory Analysis: It reveals pairwise relationships within high-dimensional datasets.\nModel Input: It serves as the foundation for complex statistical techniques, such as Exploratory Factor Analysis (EFA), Structural Equation Modeling (SEM), and linear regressions.\nDiagnostics: It acts as a health check for other models. For instance, excessively high correlations in a linear regression can signal multicollinearity, making estimates unreliable."
  },
  {
    "objectID": "HE05.2.html#visualizing-large-data-with-corrgrams",
    "href": "HE05.2.html#visualizing-large-data-with-corrgrams",
    "title": "Hands-on Exercise 5-B",
    "section": "",
    "text": "When datasets contain a high volume of observations or variables, a Corrgram is often used to detect patterns and structures. It operates on two primary principles:\n\nVisual Rendering: Mapping the sign and magnitude of correlations to specific colors or shapes.\nVariable Reordering: Grouping “similar” variables together to make clusters and relationships easier to perceive.\n\nThis hands-on exercise explores visualising correlation matrix with R. It consists of first creating matrices using the pairs() function, generating advanced corrgrams with the corrplot package, then finally building dynamic, interactive correlation matrices using plotly."
  },
  {
    "objectID": "HE05.2.html#installing-and-launching-r-packages",
    "href": "HE05.2.html#installing-and-launching-r-packages",
    "title": "Hands-on Exercise 5-B",
    "section": "2.1 Installing and Launching R Packages",
    "text": "2.1 Installing and Launching R Packages\nThe code chunk below is used to install and launch corrplot, ggpubr, plotly and tidyverse in RStudio.\n\npacman::p_load(corrplot, ggstatsplot, tidyverse)"
  },
  {
    "objectID": "HE05.2.html#importing-and-preparing-the-data-set",
    "href": "HE05.2.html#importing-and-preparing-the-data-set",
    "title": "Hands-on Exercise 5-B",
    "section": "2.2 Importing and Preparing The Data Set",
    "text": "2.2 Importing and Preparing The Data Set\nIn this hands-on exercise, the Wine Quality Data Set of UCI Machine Learning Repository will be used. The data set consists of 13 variables and 6497 observations. For the purpose of this exercise, the red wine and white wine data has been combined into one data file. It is called wine_quality and is in csv file format.\nFirst, the data is imported into R by using read_csv() of readr package.\n\nwine &lt;- read_csv(\"data/wine_quality.csv\")"
  },
  {
    "objectID": "HE05.2.html#building-a-basic-correlation-matrix",
    "href": "HE05.2.html#building-a-basic-correlation-matrix",
    "title": "Hands-on Exercise 5-B",
    "section": "3.1 Building a basic correlation matrix",
    "text": "3.1 Building a basic correlation matrix\nFigure below shows the scatter plot matrix of Wine Quality Data. It is a 11 by 11 matrix.\n\npairs(wine[,1:11])\n\n\n\n\n\n\n\n\nThe required input of pairs() can be a matrix or data frame. The code chunk used to create the scatterplot matrix is relatively simple. It uses the default pairs function. Columns 2 to 12 of wine dataframe is used to build the scatterplot matrix. The variables are: “fixed acidity”, “volatile acidity”, “citric acid”, “residual sugar”, “chlorides”, “free sulfur dioxide”, “total sulfur dioxide”, “density”, “pH”, “sulphates” and “alcohol”.\n\npairs(wine[,2:12])"
  },
  {
    "objectID": "HE05.2.html#drawing-the-lower-corner",
    "href": "HE05.2.html#drawing-the-lower-corner",
    "title": "Hands-on Exercise 5-B",
    "section": "3.2 Drawing the lower corner",
    "text": "3.2 Drawing the lower corner\npairs function of R Graphics provided many customisation arguments. For example, it is a common practice to show either the upper half or lower half of the correlation matrix instead of both. This is because a correlation matrix is symmetric.\n\nMatrix Lower HalfMatrix Upper Half\n\n\nTo show the lower half of the correlation matrix, the upper.panel argument will be used as shown in the code chunk below.\n\npairs(wine[,2:12], upper.panel = NULL)\n\n\n\n\n\n\n\n\n\n\nSimilarly, the upper half of the correlation matrix can be displayed by using the lower.panel argument.\n\npairs(wine[,2:12], lower.panel = NULL)"
  },
  {
    "objectID": "HE05.2.html#including-with-correlation-coefficients",
    "href": "HE05.2.html#including-with-correlation-coefficients",
    "title": "Hands-on Exercise 5-B",
    "section": "3.3 Including with correlation coefficients",
    "text": "3.3 Including with correlation coefficients\nTo show the correlation coefficient of each pair of variables instead of a scatter plot, panel.cor function will be used. This will also show higher correlations in a larger font.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npanel.cor &lt;- function(x, y, digits=2, prefix=\"\", cex.cor, ...) {\nusr &lt;- par(\"usr\")\non.exit(par(usr))\npar(usr = c(0, 1, 0, 1))\nr &lt;- abs(cor(x, y, use=\"complete.obs\"))\ntxt &lt;- format(c(r, 0.123456789), digits=digits)[1]\ntxt &lt;- paste(prefix, txt, sep=\"\")\nif(missing(cex.cor)) cex.cor &lt;- 0.8/strwidth(txt)\ntext(0.5, 0.5, txt, cex = cex.cor * (1 + r) / 2)\n}\n\npairs(wine[,2:12], \n      upper.panel = panel.cor)"
  },
  {
    "objectID": "HE05.2.html#getting-started-with-corrplot",
    "href": "HE05.2.html#getting-started-with-corrplot",
    "title": "Hands-on Exercise 5-B",
    "section": "6.1 Getting started with corrplot",
    "text": "6.1 Getting started with corrplot\nBefore plotting a corrgram using corrplot(), the correlation matrix of wine data frame should be computed.\nIn the code chunk below, cor() of R Stats is used to compute the correlation matrix of wine data frame.\n\nwine.cor &lt;- cor(wine[, 1:11])\n\nNext, corrplot() is used to plot the corrgram by using all the default setting as shown in the code chunk below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncorrplot(wine.cor)\n\n\n\n\nBy default, the corrgram displays as a symmetric matrix using circles as the primary visual element. It utilizes a blue-red diverging color scheme to illustrate the relationship between variables:\n\nHue (Direction): Blue represents a positive correlation, while red indicates a negative correlation.\nSaturation (Strength): The intensity of the color reflects the correlation’s magnitude. Darker, more saturated tones signify a strong linear relationship, whereas lighter, desaturated tones point to a weaker one."
  },
  {
    "objectID": "HE05.2.html#working-with-visual-geometrics",
    "href": "HE05.2.html#working-with-visual-geometrics",
    "title": "Hands-on Exercise 5-B",
    "section": "6.2 Working with visual geometrics",
    "text": "6.2 Working with visual geometrics\nThe corrplot package offers seven visual geometries (via the method parameter) to encode correlation values: circle, square, ellipse, number, shade, color, and pie.\nWhile the package defaults to the circle geometric, you can easily customize this by applying the method argument. The following code chunk demonstrates how to override the default and select an alternative visualization style.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncorrplot(wine.cor, \n         method = \"ellipse\")"
  },
  {
    "objectID": "HE05.2.html#working-with-layout",
    "href": "HE05.2.html#working-with-layout",
    "title": "Hands-on Exercise 5-B",
    "section": "6.3 Working with layout",
    "text": "6.3 Working with layout\nThe corrplot() function supports three distinct layout types:\n\n“full” (Default): Displays the entire symmetric matrix.\n“upper”: Displays only the upper triangular portion of the matrix.\n“lower”: Displays only the lower triangular portion of the matrix.\n\nThis layout can be modified by adjusting the type argument within the function.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         type=\"lower\")\n\n\n\n\nThe default corrgram layout can be further refined using additional arguments. For instance, the diag parameter allows hiding the diagonal cells, while tl.col can be used to set the axis text labels to black. These customizations are illustrated in the code chunk and resulting figure below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         type=\"lower\",\n         diag = FALSE,\n         tl.col = \"black\")"
  },
  {
    "objectID": "HE05.2.html#working-with-mixed-layout",
    "href": "HE05.2.html#working-with-mixed-layout",
    "title": "Hands-on Exercise 5-B",
    "section": "6.4 Working with mixed layout",
    "text": "6.4 Working with mixed layout\nWith corrplot package, it is possible to design corrgram with mixed visual matrix of one half and numerical matrix on the other half. In order to create a coorgram with mixed layout, the corrplot.mixed(), a wrapped function for mixed visualisation style will be used.\nFigure below shows a mixed layout corrgram plotted using wine quality data.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\nThe lower and upper arguments permits different visualization methods to each half of the matrix. In this example, an ellipse method is assigned to the lower half, while a numerical matrix (number) is used for the upper half.\nTo manage the layout further:\n\ntl.pos: Determines the placement and orientation of the axis labels.\ndiag: Specifies the type of glyph or value displayed along the principal diagonal."
  },
  {
    "objectID": "HE05.2.html#combining-corrgram-with-the-significant-test",
    "href": "HE05.2.html#combining-corrgram-with-the-significant-test",
    "title": "Hands-on Exercise 5-B",
    "section": "6.5 Combining corrgram with the significant test",
    "text": "6.5 Combining corrgram with the significant test\nIn statistical analysis, it is often crucial to identify which correlation coefficients are statistically significant rather than relying solely on their magnitude.\nThe figure below integrates a significance test into the corrgram. This visualization reveals that several variable pairings lack statistical significance. For instance, while the correlation between total sulfur dioxide and free sulfur dioxide is significant at the p &lt; 0.1 level, the relationship between total sulfurdioxide and citric acid fails to meet this threshold.\nWith corrplot package, we can use the cor.mtest() to compute the p-values and confidence interval for each pair of variables.\n\nwine.sig = cor.mtest(wine.cor, conf.level= .95)\n\nThe p.mat argument of corrplot function can then be used as shown in the code chunk below.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncorrplot(wine.cor,\n         method = \"number\",\n         type = \"lower\",\n         diag = FALSE,\n         tl.col = \"black\",\n         tl.srt = 45,\n         p.mat = wine.sig$p,\n         sig.level = .05)"
  },
  {
    "objectID": "HE05.2.html#reorder-a-corrgram",
    "href": "HE05.2.html#reorder-a-corrgram",
    "title": "Hands-on Exercise 5-B",
    "section": "6.6 Reorder a corrgram",
    "text": "6.6 Reorder a corrgram\nReordering the matrix is essential for uncovering hidden structures and patterns within a corrgram. By default, the attributes are displayed in their original order as provided in the dataset. However, this can be overwritten using the order argument.\nThe corrplot package supports four primary sorting methods:\n\n“AOE” (Angular Order of Eigenvectors): Based on the eigenvector angles; provides a smooth ordering of variables.\n“FPC” (First Principal Component): Orders variables based on their loading on the first principal component.\n“hclust” (Hierarchical Clustering): Groups similar variables together. When using this, you can specify an agglomeration method (e.g., “ward”, “average”, “complete”) via the hclust.method argument.\n“alphabet”: Arranges variables in simple alphabetical order.\n\nFor even more advanced sorting algorithms, the seriation package can be used in conjunction with corrplot.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               order=\"AOE\",\n               tl.col = \"black\")"
  },
  {
    "objectID": "HE05.2.html#reordering-a-correlation-matrix-using-hclust",
    "href": "HE05.2.html#reordering-a-correlation-matrix-using-hclust",
    "title": "Hands-on Exercise 5-B",
    "section": "6.7 Reordering a correlation matrix using hclust",
    "text": "6.7 Reordering a correlation matrix using hclust\nBy using hclust, corrplot() can draw rectangles around the corrgram based on the results of hierarchical clustering.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         tl.pos = \"lt\",\n         tl.col = \"black\",\n         order=\"hclust\",\n         hclust.method = \"ward.D\",\n         addrect = 3)"
  },
  {
    "objectID": "HE05.4.html",
    "href": "HE05.4.html",
    "title": "Hands-on Exercise 5-D",
    "section": "",
    "text": "A parallel coordinates plot is a specialized visualization technique engineered for exploring and analyzing high-dimensional, multivariate numerical data. It excels at revealing complex relationships and correlations across multiple variables simultaneously—such as the various socioeconomic factors that aggregate into a “Happiness Index.”\nDeveloped by Alfred Inselberg in the 1970s, this method is a staple in scientific and academic research but remains less common in general business reporting. Data visualization expert Stephen Few (2006) highlights its specific utility:\n“This certainly isn’t a chart that you would present to the board of directors… the strength of parallel coordinates isn’t in their ability to communicate some truth in the data to others, but rather in their ability to bring meaningful multivariate patterns and comparisons to light when used interactively for analysis.”\nIn a business context, it is particularly effective for characterizing clusters identified during customer segmentation, allowing analysts to see exactly how different segments behave across various metrics.\nThis hands-on exercise aims to give exposure to:\n\nplotting statistic parallel coordinates plots by using ggparcoord() of GGally package, and\nplotting interactive parallel coordinates plots by using parallelPlot package."
  },
  {
    "objectID": "HE05.4.html#plotting-a-simple-parallel-coordinates",
    "href": "HE05.4.html#plotting-a-simple-parallel-coordinates",
    "title": "Hands-on Exercise 5-D",
    "section": "4.1 Plotting a simple parallel coordinates",
    "text": "4.1 Plotting a simple parallel coordinates\nCode chunk below shows a typical syntax used to plot a basic static parallel coordinates plot by using ggparcoord().\n\nggparcoord(data = wh, \n           columns = c(7:12))\n\n\n\n\n\n\n\n\nNotice that only two argument namely data and columns are used. Data argument is used to map the data object (i.e. wh) and columns is used to select the columns for preparing the parallel coordinates plot."
  },
  {
    "objectID": "HE05.4.html#plotting-a-parallel-coordinates-with-boxplot",
    "href": "HE05.4.html#plotting-a-parallel-coordinates-with-boxplot",
    "title": "Hands-on Exercise 5-D",
    "section": "4.2 Plotting a parallel coordinates with boxplot",
    "text": "4.2 Plotting a parallel coordinates with boxplot\nThe basic parallel coordinates failed to reveal any meaning understanding of the World Happiness measures. This section explores how to makeover the plot by using a collection of arguments provided by ggparcoord().\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Parallel Coordinates Plot of World Happines Variables\")\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\ngroupColumn argument is used to group the observations (i.e. parallel lines) by using a single variable (i.e. Region) and colour the parallel coordinates lines by region name.\nscale argument is used to scale the variables in the parallel coordinate plot by using uniminmax method. The method univariately scale each variable so the minimum of the variable is zero and the maximum is one.\nalphaLines argument is used to reduce the intensity of the line colour to 0.2. The permissible value range is between 0 to 1.\nboxplot argument is used to turn on the boxplot by using logical TRUE. The default is FALSE.\ntitle argument is used to provide the parallel coordinates plot a title."
  },
  {
    "objectID": "HE05.4.html#parallel-coordinates-with-facet",
    "href": "HE05.4.html#parallel-coordinates-with-facet",
    "title": "Hands-on Exercise 5-D",
    "section": "4.3 Parallel coordinates with facet",
    "text": "4.3 Parallel coordinates with facet\nSince ggparcoord() is developed by extending ggplot2 package, some of the ggplot2 functions can be combined when plotting a parallel coordinates plot.\nIn the code chunk below, facet_wrap() of ggplot2 is used to plot 10 small multiple parallel coordinates plots. Each plot represent one geographical region such as East Asia.\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region)\n\n\n\n\n\n\n\n\nOne of the aesthetic defect of the current design is that some of the variable names overlap on x-axis."
  },
  {
    "objectID": "HE05.4.html#rotating-x-axis-text-label",
    "href": "HE05.4.html#rotating-x-axis-text-label",
    "title": "Hands-on Exercise 5-D",
    "section": "4.4 Rotating x-axis text label",
    "text": "4.4 Rotating x-axis text label\nTo make the x-axis text label easy to read, the labels are rotated by 30 degrees. The axis text labels can be rotated using theme() function in ggplot2 as shown in the code chunk below.\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region) + \n  theme(axis.text.x = element_text(angle = 30))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nTo rotate x-axis text labels, we use axis.text.x as argument to theme() function. The element_text(angle = 30) is specified to rotate the x-axis text by an angle 30 degree."
  },
  {
    "objectID": "HE05.4.html#adjusting-the-rotated-x-axis-text-label",
    "href": "HE05.4.html#adjusting-the-rotated-x-axis-text-label",
    "title": "Hands-on Exercise 5-D",
    "section": "4.5 Adjusting the rotated x-axis text label",
    "text": "4.5 Adjusting the rotated x-axis text label\nRotating x-axis text labels to 30 degrees makes the label overlap with the plot and this can be avoided by adjusting the text location using hjust argument to theme’s text element with element_text(). axis.text.x can be used to change the look of x-axis text.\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region) + \n  theme(axis.text.x = element_text(angle = 30, hjust=1))"
  },
  {
    "objectID": "HE05.4.html#the-basic-plot",
    "href": "HE05.4.html#the-basic-plot",
    "title": "Hands-on Exercise 5-D",
    "section": "5.1 The basic plot",
    "text": "5.1 The basic plot\nThe code chunk below plot an interactive parallel coordinates plot by using parallelPlot().\n\nwh &lt;- wh %&gt;%\n  select(\"Happiness score\", c(7:12))\nparallelPlot(wh,\n             width = 320,\n             height = 250)\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nSome of the axis labels are too long. The next steps details how to overcome this problem."
  },
  {
    "objectID": "HE05.4.html#rotate-axis-label",
    "href": "HE05.4.html#rotate-axis-label",
    "title": "Hands-on Exercise 5-D",
    "section": "5.2 Rotate axis label",
    "text": "5.2 Rotate axis label\nIn the code chunk below, rotateTitle argument is used to avoid overlapping axis labels.\n\nparallelPlot(wh,\n             rotateTitle = TRUE)\n\n\n\n\n\nA standout interactive feature of parallelPlot is the ability to apply a color gradient on demand. By simply clicking a variable, like the Happiness score, the default solid blue lines transform into a multi-toned blue color scheme. This intensity shift makes it much easier to track how different values for that specific variable behave across the rest of the plot."
  },
  {
    "objectID": "HE05.4.html#changing-the-colour-scheme",
    "href": "HE05.4.html#changing-the-colour-scheme",
    "title": "Hands-on Exercise 5-D",
    "section": "5.3 Changing the colour scheme",
    "text": "5.3 Changing the colour scheme\nThe default blue colour scheme can be changed by using continousCS argument as shown in the code chunk below.\n\nparallelPlot(wh,\n             continuousCS = \"YlOrRd\",\n             rotateTitle = TRUE)"
  },
  {
    "objectID": "HE05.4.html#parallel-coordinates-plot-with-histogram",
    "href": "HE05.4.html#parallel-coordinates-plot-with-histogram",
    "title": "Hands-on Exercise 5-D",
    "section": "5.4 Parallel coordinates plot with histogram",
    "text": "5.4 Parallel coordinates plot with histogram\nIn the code chunk below, histoVisibility argument is used to plot histogram along the axis of each variables.\n\nhistoVisibility &lt;- rep(TRUE, ncol(wh))\nparallelPlot(wh,\n             rotateTitle = TRUE,\n             histoVisibility = histoVisibility)"
  },
  {
    "objectID": "HE05.3.html",
    "href": "HE05.3.html",
    "title": "Hands-on Exercise 5-C",
    "section": "",
    "text": "Data are visualized through variations in coloring within a heatmap. When this technique is applied to a tabular format, multivariate data are cross-examined by placing variables in columns and observations (or records) in rows, with the individual cells within the table being colored accordingly.\nVariance across multiple variables is effectively demonstrated through heatmaps, allowing patterns to be revealed, similarities between variables to be displayed, and correlations between them to be detected.\nIn this hands-on exercise, practical experience will be gained in using R to plot both static and interactive heatmaps. These tools will be utilized for the visualization and analysis of multivariate data."
  },
  {
    "objectID": "HE05.3.html#installing-and-launching-r-packages",
    "href": "HE05.3.html#installing-and-launching-r-packages",
    "title": "Hands-on Exercise 5-C",
    "section": "2.1 Installing and Launching R Packages",
    "text": "2.1 Installing and Launching R Packages\nThe code chunk below is used to install and launch seriation, heatmaply, dendextend and tidyverse in RStudio.\n\npacman::p_load(seriation, dendextend, heatmaply, tidyverse)"
  },
  {
    "objectID": "HE05.3.html#importing-and-preparing-the-data-set",
    "href": "HE05.3.html#importing-and-preparing-the-data-set",
    "title": "Hands-on Exercise 5-C",
    "section": "2.2 Importing and Preparing The Data Set",
    "text": "2.2 Importing and Preparing The Data Set\nFor the exercise, the data of World Happines 2018 report will be used. The data set is downloaded from here. The original data set is in Microsoft Excel format. It has been extracted and saved in csv file called WHData-2018.csv.\nIn the code chunk below, read_csv() of readr is used to import WHData-2018.csv into R and parsed it into tibble R data frame format. The output tibbled data frame is called wh.\n\nwh &lt;- read_csv(\"data/WHData-2018.csv\")\n\nThe rows are then updated to reflect country names rather than row numbers.\n\nrow.names(wh) &lt;- wh$Country\n\nAs shown in the output, the numeric indices have been successfully replaced by country identifiers.\nThe data was loaded into a data frame, but it has to be a data matrix to create the heatmap. The code chunk below will be used to transform wh data frame into a data matrix.\n\nwh1 &lt;- dplyr::select(wh, c(3, 7:12))\nwh_matrix &lt;- data.matrix(wh)\n\nNotice that wh_matrix is in R matrix format."
  },
  {
    "objectID": "HE05.3.html#heatmap-of-r-stats",
    "href": "HE05.3.html#heatmap-of-r-stats",
    "title": "Hands-on Exercise 5-C",
    "section": "3.1 heatmap() of R Stats",
    "text": "3.1 heatmap() of R Stats\nIn this sub-section, a heat map by using heatmap() of Base Stats is plotted. The code chunk is given below.\n\nwh_heatmap &lt;- heatmap(wh_matrix,\n                      Rowv=NA, Colv=NA)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nBy default, heatmap() plots a cluster heatmap. The arguments Rowv=NA and Colv=NA are used to switch off the option of plotting the row and column dendrograms.\n\n\nTo plot a cluster heatmap, the default has to be used, as shown in the code chunk below.\n\nwh_heatmap &lt;- heatmap(wh_matrix)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe order of both rows and columns is different compare to the native wh_matrix. This is because heatmap do a reordering using clusterisation: it calculates the distance between each pair of rows and columns and try to order them by similarity. Moreover, the corresponding dendrogram are provided beside the heatmap.\n\n\nIn this context, small values are denoted by red cells, as are the smaller values overall. The resulting heatmap is found to be uninformative. Because the Happiness Score variable possesses relatively higher values, other variables with smaller magnitudes are rendered indistinguishable from one another.\nConsequently, the normalization of the matrix is required. This is achieved through the application of the scale argument, which may be applied to either rows or columns depending on the specific analytical requirements.\nThe code chunk below normalises the matrix column-wise.\n\nwh_heatmap &lt;- heatmap(wh_matrix,\n                      scale=\"column\",\n                      cexRow = 0.6, \n                      cexCol = 0.8,\n                      margins = c(10, 4))\n\n\n\n\n\n\n\n\nNotice that the values are scaled now. Also note that margins argument is used to ensure that the entire x-axis labels are displayed completely and, cexRow and cexCol arguments are used to define the font size used for y-axis and x-axis labels respectively."
  },
  {
    "objectID": "HE05.3.html#data-transformation",
    "href": "HE05.3.html#data-transformation",
    "title": "Hands-on Exercise 5-C",
    "section": "4.1 Data transformation",
    "text": "4.1 Data transformation\nDuring the analysis of multivariate datasets, variables reflecting diverse measurement types and ranges are frequently encountered. To ensure comparability across these variables, data transformation is commonly performed prior to clustering.\nThree primary transformation methods are supported by the heatmaply() package: scaling, normalizing, and percentizing.\n\n4.1.1 Scaling Method\nIf variables are assumed to follow a normal distribution, scaling is applied by subtracting the mean and dividing by the standard deviation. This process centers the data, bringing it closer to a standard normal distribution where each value represents the distance from the mean in units of standard deviation. Column and row scaling are both supported via the scale argument.\nThe code chunk below is used to scale variable values columewise.\n\nheatmaply(wh_matrix[, -c(1, 2, 4, 5)],\n          scale = \"column\")\n\n\n\n\n\n\n\n4.1.2 Normalizing Method\nWhen data are derived from non-normal or differing distributions, normalization is utilized to shift the data onto a 0 to 1 scale. This is achieved by subtracting the minimum value and dividing by the range (maximum minus minimum). Through this method, the original shape of each variable’s distribution is preserved while making the variables comparable.\nDifferent from Scaling, the normalise method is performed on the input data set i.e. wh_matrix as shown in the code chunk below.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\n4.1.3 Percentizing Method\nThis approach is similar to ranking variables, where rank values are divided by the maximum rank. By using the Empirical Cumulative Distribution Function (ECDF), each value is converted to its empirical percentile. This provides a clear interpretation: each value represents the percentage of observations that fall at or below that specific level.\nSimilar to Normalize method, the Percentize method is also performed on the input data set i.e. wh_matrix as shown in the code chunk below.\n\nheatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))"
  },
  {
    "objectID": "HE05.3.html#clustering-algorithm",
    "href": "HE05.3.html#clustering-algorithm",
    "title": "Hands-on Exercise 5-C",
    "section": "4.2 Clustering algorithm",
    "text": "4.2 Clustering algorithm\nA variety of hierarchical clustering algorithms are supported by heatmaply, with calibration achievable through both manual and statistical methods. The primary arguments used to define these models include:\n\ndistfun: This function computes the distance (dissimilarity) between rows and columns. While it defaults to dist, correlation-based clustering can be implemented using “pearson”, “spearman”, or “kendall”. In these cases, the distance metric is defined as \\(as.dist(1 - cor(t(x)))\\).\nhclustfun: This defines the function used for hierarchical clustering when Rowv or Colv are not already provided as dendrograms. The default setting is hclust.\ndist_method: This defaults to “euclidean” if left as NULL. It accepts character strings to specify the method passed to distfun, such as “maximum”, “manhattan”, “canberra”, “binary”, or “minkowski”.\nhclust_method: This defaults to the “complete” linkage method. It allows for various character strings to be passed to hclustfun, including “ward.D”, “ward.D2”, “single”, “average” (UPGMA), “centroid” (UPGMC), and others."
  },
  {
    "objectID": "HE05.3.html#manual-approach",
    "href": "HE05.3.html#manual-approach",
    "title": "Hands-on Exercise 5-C",
    "section": "4.3 Manual approach",
    "text": "4.3 Manual approach\nIn the code chunk below, the heatmap is plotted by using hierachical clustering algorithm with “Euclidean distance” and “ward.D” method.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\")"
  },
  {
    "objectID": "HE05.3.html#statistical-approach",
    "href": "HE05.3.html#statistical-approach",
    "title": "Hands-on Exercise 5-C",
    "section": "4.4 Statistical approach",
    "text": "4.4 Statistical approach\nIn order to determine the best clustering method and number of cluster the dend_expend() and find_k() functions of dendextend package will be used.\nFirst, the dend_expend() will be used to determine the recommended clustering method to be used.\n\nwh_d &lt;- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), method = \"euclidean\")\ndend_expend(wh_d)[[3]]\n\n  dist_methods hclust_methods     optim\n1      unknown         ward.D 0.6137851\n2      unknown        ward.D2 0.6289186\n3      unknown         single 0.4774362\n4      unknown       complete 0.6434009\n5      unknown        average 0.6701688\n6      unknown       mcquitty 0.5020102\n7      unknown         median 0.5901833\n8      unknown       centroid 0.6338734\n\n\nThe output table shows that “average” method should be used because it gave the high optimum value.\nNext, find_k() is used to determine the optimal number of cluster.\n\nwh_clust &lt;- hclust(wh_d, method = \"average\")\nnum_k &lt;- find_k(wh_clust)\nplot(num_k)\n\n\n\n\n\n\n\n\nFigure above shows that k=3 would be good.\nWith reference to the statistical analysis results, we can prepare the code chunk as shown below.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"average\",\n          k_row = 3)"
  },
  {
    "objectID": "HE05.3.html#seriation",
    "href": "HE05.3.html#seriation",
    "title": "Hands-on Exercise 5-C",
    "section": "4.5 Seriation",
    "text": "4.5 Seriation\nA significant limitation of hierarchical clustering is that it does not dictate a definitive linear order for rows; rather, it merely restricts the possible arrangements.\n\n4.5.1 The Ordering Problem\nConsider three items: A, B, and C. Excluding reflections, three unique orderings are possible: ABC, ACB, and BAC. If a clustering algorithm produces a tree structure of ((A+B)+C), the logic dictates that C cannot be placed between A and B. However, the algorithm does not determine the orientation of the A+B cluster. Consequently, it remains unclear whether an ABC or ACB sequence will result in a more coherent visualization.\n\n\n4.5.2 Seriation and Optimal Leaf Ordering (OLO)\nTo resolve this, heatmaply utilizes the seriation package to identify an optimal arrangement for rows and columns. This process optimizes the Hamiltonian path length within the constraints of the dendrogram. Essentially, branches are rotated to minimize the sum of distances between adjacent leaves—a task mathematically related to a restricted version of the Traveling Salesman Problem.\nThe primary algorithm employed for this is Optimal Leaf Ordering (OLO). OLO takes the output of agglomerative clustering and produces a unique, optimized sequence by flipping dendrogram branches to minimize dissimilarity between neighboring labels. This results in a cleaner, more interpretable heatmap structure.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"OLO\")\n\n\n\n\n\nThe default options is “OLO” (Optimal leaf ordering) which optimizes the above criterion (in O(n^4)). Another option is “GW” (Gruvaeus and Wainer) which aims for the same goal but uses a potentially faster heuristic.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"GW\")\n\n\n\n\n\nThe option “mean” gives the output we would get by default from heatmap functions in other packages such as gplots::heatmap.2.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"mean\")\n\n\n\n\n\nThe option “none” gives us the dendrograms without any rotation that is based on the data matrix.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\")"
  },
  {
    "objectID": "HE05.3.html#working-with-colour-palettes",
    "href": "HE05.3.html#working-with-colour-palettes",
    "title": "Hands-on Exercise 5-C",
    "section": "4.6 Working with colour palettes",
    "text": "4.6 Working with colour palettes\nThe default colour palette uses by heatmaply is viridis. heatmaply users, however, can use other colour palettes in order to improve the aestheticness and visual friendliness of the heatmap.\nIn the code chunk below, the Blues colour palette of rColorBrewer is used.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\",\n          colors = Blues)"
  },
  {
    "objectID": "HE05.3.html#the-finishing-touch",
    "href": "HE05.3.html#the-finishing-touch",
    "title": "Hands-on Exercise 5-C",
    "section": "4.7 The finishing touch",
    "text": "4.7 The finishing touch\nBeside providing a wide collection of arguments for meeting the statistical analysis needs, heatmaply also provides many plotting features to ensure cartographic quality heatmap can be produced.\nIn the code chunk below the following arguments are used:\n\nk_row is used to produce 5 groups.\nmargins is used to change the top margin to 60 and row margin to 200.\nfontsize_row and fontsize_col are used to change the font size for row and column labels to 4.\nmain is used to write the main title of the plot.\nxlab and ylab are used to write the x-axis and y-axis labels respectively.\n\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          Colv=NA,\n          seriate = \"none\",\n          colors = Blues,\n          k_row = 5,\n          margins = c(150,200,100,20),\n          fontsize_row = 4,\n          fontsize_col = 8,\n          main=\"World Happiness Score and Variables by Country, 2018 \\nDataTransformation using Normalise Method\",\n          xlab = \"World Happiness Indicators\",\n          ylab = \"World Countries\"\n          )"
  },
  {
    "objectID": "HE05.5.html",
    "href": "HE05.5.html",
    "title": "Hands-on Exercise 5-E",
    "section": "",
    "text": "This hands-on exercise focuses on designing treemaps using appropriate R packages. Three main sections are included:\n\nData Manipulation: Transaction data is manipulated into a treemap structure using selected functions from the dplyr package.\nStatic Treemaps: Static treemaps are plotted using the treemap package.\nInteractive Treemaps: Interactive treemaps are designed using the d3treeR package."
  },
  {
    "objectID": "HE05.5.html#data-wrangling-and-manipulation",
    "href": "HE05.5.html#data-wrangling-and-manipulation",
    "title": "Hands-on Exercise 5-E",
    "section": "3.1 Data Wrangling and Manipulation",
    "text": "3.1 Data Wrangling and Manipulation\nThe realis2018 data frame exists in a transaction record format, which is highly disaggregated and unsuitable for plotting a treemap. To prepare a data frame appropriate for treemap visualization, the following steps are performed:\n\nTransaction records are grouped by Project Name, Planning Region, Planning Area, Property Type, and Type of Sale.\nTotal Unit Sold, Total Area, Median Unit Price, and Median Transacted Price are computed by applying summary statistics to No. of Units, Area (sqm), Unit Price ($ psm), and Transacted Price ($), respectively.\n\nThe group_by() and summarize() functions from the dplyr package are utilized to execute these tasks. The group_by() function breaks a data frame into specified groups of rows, ensuring that subsequent operations are automatically applied “by group”.\nGrouping affects dplyr verbs in the following ways:\n\nselect(): Grouped selection functions identically to ungrouped selection, though grouping variables are always retained.\narrange(): Grouped arrangement remains the same as ungrouped unless .by_group = TRUE is set, which orders the data by grouping variables first.\nmutate() and filter(): These are most effective when used with window functions (such as rank()); further details are available in vignette(\"window-functions\").\nsample_n() and sample_frac(): These functions sample a specified number or fraction of rows from each individual group.\nsummarise(): This function computes a summary for each defined group.\n\nIn this specific application, group_by() is paired with summarise() to derive the required summarized data frame."
  },
  {
    "objectID": "HE05.5.html#grouped-summaries-without-the-pipe",
    "href": "HE05.5.html#grouped-summaries-without-the-pipe",
    "title": "Hands-on Exercise 5-E",
    "section": "3.2 Grouped summaries without the Pipe",
    "text": "3.2 Grouped summaries without the Pipe\nThe code chank below shows a typical two lines code approach to perform the steps.\n\nrealis2018_grouped &lt;- group_by(realis2018, `Project Name`,\n                               `Planning Region`, `Planning Area`, \n                               `Property Type`, `Type of Sale`)\nrealis2018_summarised &lt;- summarise(realis2018_grouped, \n                          `Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE),\n                          `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n                          `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE), \n                          `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n\n\n\n\n\n\n\nNote\n\n\n\nAggregation functions such as sum() and meadian() obey the usual rule of missing values:\nif there’s any missing value in the input, the output will be a missing value. The argument na.rm = TRUE removes the missing values prior to computation."
  },
  {
    "objectID": "HE05.5.html#grouped-summaries-with-the-pipe",
    "href": "HE05.5.html#grouped-summaries-with-the-pipe",
    "title": "Hands-on Exercise 5-E",
    "section": "3.3 Grouped summaries with the pipe",
    "text": "3.3 Grouped summaries with the pipe\nThe code chunk below shows a more efficient way to tackle the same processes by using the pipe, %&gt;%\n\nrealis2018_summarised &lt;- realis2018 %&gt;% \n  group_by(`Project Name`,`Planning Region`, \n           `Planning Area`, `Property Type`, \n           `Type of Sale`) %&gt;%\n  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), \n            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),\n            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))"
  },
  {
    "objectID": "HE05.5.html#designing-a-static-treemap",
    "href": "HE05.5.html#designing-a-static-treemap",
    "title": "Hands-on Exercise 5-E",
    "section": "4.1 Designing a static treemap",
    "text": "4.1 Designing a static treemap\nIn this section, the treemap() function from the treemap package is utilized to visualize the distribution of median unit prices and total units sold for resale condominiums based on geographic hierarchy in 2017.\nInitially, records belonging to the “resale condominium” property type are selected from the realis2018_selected data frame.\n\nrealis2018_selected &lt;- realis2018_summarised %&gt;%\n  filter(`Property Type` == \"Condominium\", `Type of Sale` == \"Resale\")"
  },
  {
    "objectID": "HE05.5.html#using-the-basic-arguments",
    "href": "HE05.5.html#using-the-basic-arguments",
    "title": "Hands-on Exercise 5-E",
    "section": "4.2 Using the basic arguments",
    "text": "4.2 Using the basic arguments\nThe code chunk below designed a treemap by using three core arguments of treemap(), namely: index, vSize and vColor.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\nThings to learn from the three arguments used:\n\nindex:\n\nThe index vector must consist of at least two column names or else no hierarchy treemap will be plotted.\nIf multiple column names are provided, such as the code chunk above, the first name is the highest aggregation level, the second name the second highest aggregation level, and so on.\n\nvSize:\n\nThe column must not contain negative values. This is because its values will be used to map the sizes of the rectangles of the treemaps.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe treemap above was wrongly coloured. For a correctly designed treemap, the colours of the rectangles should be in different intensity showing, in this case, median unit prices.\nFor treemap(), vColor is used in combination with the argument type to determines the colours of the rectangles. Without defining type, like the code chunk above, treemap() assumes type = index, in this case, the hierarchy of planning areas."
  },
  {
    "objectID": "HE05.5.html#working-with-vcolor-and-type-arguments",
    "href": "HE05.5.html#working-with-vcolor-and-type-arguments",
    "title": "Hands-on Exercise 5-E",
    "section": "4.3 Working with vColor and type arguments",
    "text": "4.3 Working with vColor and type arguments\nIn the code chunk below, type argument is define as value.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type = \"value\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\nThings to learn from the code chunk above:\n\nThe rectangles are coloured with different intensity of green, reflecting their respective median unit prices.\nThe legend reveals that the values are binned into ten bins, i.e. 0-5000, 5000-10000, etc. with an equal interval of 5000."
  },
  {
    "objectID": "HE05.5.html#colours-in-treemap-package",
    "href": "HE05.5.html#colours-in-treemap-package",
    "title": "Hands-on Exercise 5-E",
    "section": "4.4 Colours in treemap package",
    "text": "4.4 Colours in treemap package\nTwo arguments determine the mapping to color palettes: mapping and palette. The primary distinction between the “value” and “manual” options lies in the default value for mapping.\nThe “value” treemap treats the palette as a diverging color scheme, such as ColorBrewer’s “RdYlBu.” It maps the data so that the value 0 corresponds to the middle color, while the extreme values (-max(abs(values)) and +max(abs(values))) are mapped to the left-end and right-end colors, respectively.\nIn contrast, the “manual” treemap maps the minimum value to the left-end color, the maximum value to the right-end color, and the mean of the range to the middle color."
  },
  {
    "objectID": "HE05.5.html#the-value-type-treemap",
    "href": "HE05.5.html#the-value-type-treemap",
    "title": "Hands-on Exercise 5-E",
    "section": "4.5 The “value” type treemap",
    "text": "4.5 The “value” type treemap\nThe code chunk below shows a value type treemap.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\nThing to learn from the code chunk above:\n\nalthough the colour palette used is RdYlBu but there are no red rectangles in the treemap above. This is because all the median unit prices are positive.\nThe reason why we see only 5000 to 45000 in the legend is because the range argument is by default c(min(values, max(values)) with some pretty rounding."
  },
  {
    "objectID": "HE05.5.html#the-manual-type-treemap",
    "href": "HE05.5.html#the-manual-type-treemap",
    "title": "Hands-on Exercise 5-E",
    "section": "4.6 The “manual” type treemap",
    "text": "4.6 The “manual” type treemap\nThe “manual” type does not interpret the values as the “value” type does. Instead, the value range is mapped linearly to the colour palette.\nThe code chunk below shows a manual type treemap.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\nThings to learn from the code chunk above:\n\nThe colour scheme used is very confusing. This is because mapping = (min(values), mean(range(values)), max(values)). It is not wise to use diverging colour palette such as RdYlBu if the values are all positive or negative\n\nTo overcome this problem, a single colour palette such as Blues should be used.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )"
  },
  {
    "objectID": "HE05.5.html#treemap-layout",
    "href": "HE05.5.html#treemap-layout",
    "title": "Hands-on Exercise 5-E",
    "section": "4.7 Treemap Layout",
    "text": "4.7 Treemap Layout\ntreemap() supports two popular treemap layouts, namely: “squarified” and “pivotSize”. The default is “pivotSize”.\nThe squarified treemap algorithm (Bruls et al., 2000) produces good aspect ratios, but ignores the sorting order of the rectangles (sortID). The ordered treemap, pivot-by-size, algorithm (Bederson et al., 2002) takes the sorting order (sortID) into account while aspect ratios are still acceptable."
  },
  {
    "objectID": "HE05.5.html#working-with-algorithm-argument",
    "href": "HE05.5.html#working-with-algorithm-argument",
    "title": "Hands-on Exercise 5-E",
    "section": "4.8 Working with algorithm argument",
    "text": "4.8 Working with algorithm argument\nThe code chunk below plots a squarified treemap by changing the algorithm argument.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"squarified\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )"
  },
  {
    "objectID": "HE05.5.html#using-sortid",
    "href": "HE05.5.html#using-sortid",
    "title": "Hands-on Exercise 5-E",
    "section": "4.9 Using sortID",
    "text": "4.9 Using sortID\nWhen “pivotSize” algorithm is used, sortID argument can be used to dertemine the order in which the rectangles are placed from top left to bottom right.\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"pivotSize\",\n        sortID = \"Median Transacted Price\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )"
  },
  {
    "objectID": "HE05.5.html#designing-a-basic-treemap",
    "href": "HE05.5.html#designing-a-basic-treemap",
    "title": "Hands-on Exercise 5-E",
    "section": "5.1 Designing a basic treemap",
    "text": "5.1 Designing a basic treemap\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`),\n       layout = \"scol\",\n       start = \"bottomleft\") + \n  geom_treemap() +\n  scale_fill_gradient(low = \"light blue\", high = \"blue\")"
  },
  {
    "objectID": "HE05.5.html#defining-hierarchy",
    "href": "HE05.5.html#defining-hierarchy",
    "title": "Hands-on Exercise 5-E",
    "section": "5.2 Defining hierarchy",
    "text": "5.2 Defining hierarchy\nGroup by Planning Region\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`),\n       start = \"topleft\") + \n  geom_treemap()\n\n\n\n\nGroup by Planning Area\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap()\n\n\n\n\nAdding boundary line\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap() +\n  geom_treemap_subgroup2_border(colour = \"gray40\",\n                                size = 2) +\n  geom_treemap_subgroup_border(colour = \"gray20\")"
  },
  {
    "objectID": "HE05.5.html#installing-d3treer-package",
    "href": "HE05.5.html#installing-d3treer-package",
    "title": "Hands-on Exercise 5-E",
    "section": "6.1 Installing d3treeR package",
    "text": "6.1 Installing d3treeR package\nThis section shows how to install a R package which is not available in cran.\n\nIf this is the first time installing a package from github, devtools package should be installed by using the code below or else this can be skipped.\n\n# install.packages(\"devtools\")\n\n\n\n\nNext, you will load the devtools library and install the package found in github by using the codes below.\n\nlibrary(devtools)\ninstall_github(\"timelyportfolio/d3treeR\")\n\n\n\n\nNow you are ready to launch d3treeR package.\n\nlibrary(d3treeR)"
  },
  {
    "objectID": "HE05.5.html#designing-an-interactive-treemap",
    "href": "HE05.5.html#designing-an-interactive-treemap",
    "title": "Hands-on Exercise 5-E",
    "section": "6.2 Designing An Interactive Treemap",
    "text": "6.2 Designing An Interactive Treemap\nThe codes below perform two processes.\n\ntreemap() is used to build a treemap by using selected variables in condominium data.frame. The treemap created is save as object called tm.\n\ntm &lt;- treemap(realis2018_summarised,\n        index=c(\"Planning Region\", \"Planning Area\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        title=\"Private Residential Property Sold, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThen d3tree() is used to build an interactive treemap.\n\nd3tree(tm,rootname = \"Singapore\" )"
  }
]